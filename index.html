<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Terge&#39;s Android Life | 主动、无畏、习惯、沉淀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Terge's Android Life">
<meta property="og:url" content="http://terge.me/index.html">
<meta property="og:site_name" content="Terge's Android Life">
<meta property="og:description" content="description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Terge's Android Life">
<meta name="twitter:description" content="description">
  
    <link rel="alternative" href="/atom.xml" title="Terge&#39;s Android Life" type="application/atom+xml">
  
  <meta name="summary" content="description">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">唐自刚</h5>
        <a href="mailto:undefined" title="i.terge.me@gmail.com" class="mail">i.terge.me@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Tags
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/terge" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="http://www.weibo.com/zigtang" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>
            Weibo
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/404"  >
            <i class="icon icon-lg icon-link"></i>
            测试
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Terge&#39;s Android Life &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Terge&#39;s Android Life</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Terge&#39;s Android Life</h1>
    <h5 class="subtitle">
        
        主动、无畏、习惯、沉淀
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <ul class="post-list">
  
    <li class="post-list-item">
        <article id="post-说一下Handler的原理" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/07/16/说一下Handler的原理/">说一下Handler的原理</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-07-16T07:33:31.000Z" itemprop="datePublished" class="post-time">
  2016-07-16
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h2 id="Part1-Handler原理概述"><a href="#Part1-Handler原理概述" class="headerlink" title="Part1 : Handler原理概述"></a>Part1 : Handler原理概述</h2><h4 id="Handler在解决什么问题"><a href="#Handler在解决什么问题" class="headerlink" title="Handler在解决什么问题?"></a>Handler在解决什么问题?</h4><p>“handler 是为了解决线程间通讯的问题而设计的”</p>
<p>对于这个回答我是不满意的：　　</p>
<pre><code>１．解决线程通讯一个通用的回调就可以，何必整真么多事出来
    线程通讯是终极目的，在设计这个过程中还包括消息队列排队、循环读取消息、阻塞等待的逻辑　　
    学习它如何优雅的设计这个通讯方案，是值得我们去深挖的
２．handler给我们的印象是更新UI用的，如何与线程通讯联系起来
    因为大多数情况我们是用来是子线程来通知主线程来操作的，而一般是通知主线程是更新UI　　
    所以给我们造成这样一种误解：&quot;handler是更新UI&quot;　　
    其实handler可以用来跟随意两个子线程通讯
</code></pre><h4 id="Handler提供的接口"><a href="#Handler提供的接口" class="headerlink" title="Handler提供的接口"></a>Handler提供的接口</h4><p>handler主要提供这两个功能（其他一些功能都是围绕这两个转的）</p>
<pre><code>1. 发消息        sendMessageAt()
2. 处理消息      handleMessage()
</code></pre><p>这里对应就有两个疑问了:</p>
<pre><code>1. 它的消息发给谁？
2. 消息又是由谁来消费的?
</code></pre><p>看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler<br>了解他们是如何协同工作的才能回答上述两个疑问</p>
<p><img src="http://oaumghlfk.bkt.clouddn.com/handler.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10" alt="Handler-flow"></p>
<ol>
<li>ThreadA持有handler，此handler是使用线程B的Looper来实例化的，发送的消息是将其入队到ThreadB.Looper.MessageQueue中</li>
<li>MessageQueue中的消息会被与之对应的Looper逐个取出来</li>
<li>执行Looper中的消息的主体是与Looper对应的ThreadB</li>
<li>ThreadB只是调用message.target.dispatchMessage</li>
<li>这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.dispatchMessage</li>
<li>但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑(也就是我们覆写的handlerMessage)是在ThreadB上执行的</li>
</ol>
<p>他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,hander的消息就是入队到这个Looper的MQ中，一个线程最多只有一个Looper，线程会从Looper中取出消息来执行.<br>我们一般使用Handler时候也是这样，在主线程实例化Handler，相当于使用主线程的Looper来实例化Handler,将此Handler的引用给到子线程，在需要时候子线程通过handler发消息，就会将消息入队到主线程的Looper中，从而在主线程中执行.<br>主线程的Looper是在主线程实例化时候就已经准备好的，所以我们不需要调用Looper.prepare(),当我们需要子线程的Looper来实例化Handler的时候，就需要主动调用Looper.prepare().</p>
<p>再来回答那两个问题：</p>
<ol>
<li>它的消息发给谁？<br> Handler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中</li>
<li>消息又是由谁来消费的?<br> 这个Looper对应的线程是哪一个，消息就会被那个线程消费</li>
</ol>
<h2 id="Part2-源码分析"><a href="#Part2-源码分析" class="headerlink" title="Part2 : 源码分析"></a>Part2 : 源码分析</h2><p>以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭　　<br>注意：Handler中所有的发消息接口如下图选中的postxxx和sendxxx</p>
<p><img src="http://oaumghlfk.bkt.clouddn.com/handler-api.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10" alt="Handler-api">　　<br>这些接口都只是在封装Message，最终都是调用到sendMessageAtTime，所以我们只看sendMessageAtTime即可</p>
<h4 id="Handler-sendMessageAtTime"><a href="#Handler-sendMessageAtTime" class="headerlink" title="Handler.sendMessageAtTime()"></a>Handler.sendMessageAtTime()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler.sendMessageAtTime 最终将消息入队列</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继续看Handler.enqueueMessage</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)<br>那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler</span></div><div class="line"><span class="keyword">final</span> MessageQueue mQueue;</div><div class="line"><span class="keyword">final</span> Looper mLooper;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">		...</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    mLooper = looper;</div><div class="line">    mQueue = looper.mQueue;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>呐，还有我们熟悉的异常：
&quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;　　
Handler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看
所以出现此问题的处理方式：要么是直接传递Looper进来，要么是在实例化时候调用Looper.prepare()
然而Ｌooper.prepare()只能调用一次，如果已经prepare过了，再调用会抛异常,处理方式如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(Looper.myLooper() == <span class="keyword">null</span>)&#123;</div><div class="line">	Looper.prepare();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>Handler 在实例化时候就会初始化Looper和MQ<br>上面Handler.sendMessage,msg最终是入到队列里了，这个MQ就是Looper.mQueue<br>并且Looper和MQ都是final的，Handler构造完之后就不可改变<br>到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑</p>
<h4 id="MessageQueue-enqueueMessage"><a href="#MessageQueue-enqueueMessage" class="headerlink" title="MessageQueue.enqueueMessage()"></a>MessageQueue.enqueueMessage()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MessageQueue.enqueueMessage</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">	<span class="comment">//这个target就是handler引用</span></div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//消息不能重复使用，有需要记得clone一份</span></div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">	<span class="comment">//队列已经退出的逻辑处理</span></div><div class="line">	<span class="comment">//mQuitting状态标识是在MQ.quit()方法中被设为true的</span></div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//消息是在这里设置成已经消费了</span></div><div class="line">        msg.markInUse();</div><div class="line">	<span class="comment">//时间是在入队时候指定的，之前手动给消息赋时间没有意义</span></div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">	<span class="comment">//空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头</span></div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">		<span class="comment">//MQ中的消息是根据msg.when来排序的</span></div><div class="line">		<span class="comment">//根据msg.when给新来的Msg找个合适的位置插进去</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">		<span class="comment">//1. p == null，说明找到队列尾部了还是没找到合适位置</span></div><div class="line">		<span class="comment">//2. when &lt; p.when 说明找到一个比自己还要晚展示的消息</span></div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">		<span class="comment">//插入msg</span></div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>啥也不说了，都在酒里了，哦不，在注释里<br>上面说了具体的Message入队的细节，还是没有讲入队之后的事情<br>那接下来就要去MQ对应的Looper里面看实现了</p>
<h4 id="Lopper-loop"><a href="#Lopper-loop" class="headerlink" title="Lopper.loop()"></a>Lopper.loop()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Lopper.loop()</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">				...</div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">				...</div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper.loop执行逻辑是循环读取MQ中的mesage，然后执行message.target.dispatchMessage<br>而这个message.target就是在enqueue时候制定的handler<br>那，我们再跟踪到Handler.dispatchMessage去看看</p>
<h4 id="Handler-dispatchMessage"><a href="#Handler-dispatchMessage" class="headerlink" title="Handler.dispatchMessage()"></a>Handler.dispatchMessage()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler.dispatchMessage</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line"><span class="comment">//此处的msg.callback也就是postRunanable发送的runable</span></div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">//注意这个mCallback不要与msg.callback混了</span></div><div class="line">	<span class="comment">//这个是handler的callback.后面在讲HandlerThread时候会讲到这里</span></div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	<span class="comment">//呐，回到了我们覆写的handleMessage方法</span></div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>loop这里有几点需要注意：</p>
<pre><code>1. loop方法是个死循环：for (;;) {}
2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（读者自行跟踪下，答对我送你一个惊喜）
</code></pre><h2 id="Part3-扩展"><a href="#Part3-扩展" class="headerlink" title="Part3 扩展"></a>Part3 扩展</h2><h4 id="ThreadLoacal是什么鬼"><a href="#ThreadLoacal是什么鬼" class="headerlink" title="ThreadLoacal是什么鬼"></a>ThreadLoacal是什么鬼</h4><p>市面上Handler都要提到theadLocal,如果我不提是不是显得我不够深入？<br>将其理解成Thread一个Map就好，想深入了解的自行Google,个人觉得这与主题扯不上关系</p>
<h4 id="Message-when"><a href="#Message-when" class="headerlink" title="Message.when"></a>Message.when</h4><p>MQ是按照Message.when来进行排序的，消息入队时候会按照当前消息要展示的是事件来放到合适的位置，如果直接指定sendMessageAt的时间为０，就会直接放在队头，Handler提供的接口 sendMessage() postRunnable() sendMessageAtFrontOfQueue…这些都只是指定了sendMessageAt(msg,0),这个时间０就会赋值给message.when</p>
<p>但是when可以修改么？<br>when是package访问权限(还好不是final)，可以通过新建一个与其包名相同的类来修改？<br>when值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，入队之后这个值就没有意义了，所以我们修改它也没有意义</p>
<h4 id="Message-target"><a href="#Message-target" class="headerlink" title="Message.target"></a>Message.target</h4><p>Handler.obtain系列会将Message.target赋值为this<br>而Handler.postRunnable 获取的Message没有赋值target<br>但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this<br>也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper<br>但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中</p>
<h4 id="sendMessage与postRunable有什么区别"><a href="#sendMessage与postRunable有什么区别" class="headerlink" title="sendMessage与postRunable有什么区别"></a>sendMessage与postRunable有什么区别</h4><p>handler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是发送一个消息　　<br>如果你愿意，完全可以实例化一个Ｍessage，将runable赋值给msg.callback，再通过handler.sendMessage来发送runnable<br>注:这种方式可以用于统一处理，比如switch-case中，有的case是sendMessage,有的是postRunanable,这样就可以在case里面只处理Message，对于postRunanable的情况也使用message来处理，在switch-case的外层统一调用sendMessage来发送</p>
<h4 id="Handler消费消息时候处理的优先顺序"><a href="#Handler消费消息时候处理的优先顺序" class="headerlink" title="Handler消费消息时候处理的优先顺序"></a>Handler消费消息时候处理的优先顺序</h4><p>Handler处理消息是按如下顺序来处理的<br>msg.callback –&gt; handler.callback –&gt; handler.handlerMessage(msg)<br>如果设置了msg.callback,那么会优先处理，此时对其设置的msg.what 和msg.obj都是没有意义的<br>handler.callback一般我们不会设置，后续理解HandlerThread会讲到，如果设置了handler.callback，那么消息也不会进入handlerMessage里面的<br>最后才是使用handler.handlerMessage来消费此消息</p>
<h4 id="如何停止Looper"><a href="#如何停止Looper" class="headerlink" title="如何停止Looper"></a>如何停止Looper</h4><p>Looper在loop的时候，如果取到一个Message为null，就会自行跳出，只有在MQ为空或者MQ已经退出了才会给Looper返回null. 但不能通过发送null消息来停止<br>调用Looper.quit()可以停止Looper，实际上是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束</p>
<h4 id="聊一聊HandlerThread"><a href="#聊一聊HandlerThread" class="headerlink" title="聊一聊HandlerThread"></a>聊一聊HandlerThread</h4><p>本来想一起写的，发现这一主题也可以写很多东西出来，后面会单独写一篇来梳理HandlerThread</p>
<h4 id="为什么框架层要提示防止内存泄露？"><a href="#为什么框架层要提示防止内存泄露？" class="headerlink" title="为什么框架层要提示防止内存泄露？"></a>为什么框架层要提示防止内存泄露？</h4><p>我们在使用Handler时候，如果直接在主线程实例化一个线程，会有如下警告提示：</p>
<pre><code>&quot;This Handler class should be static or leaks might occur .
Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected.
If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue.
If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration,
as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer
class and pass this object to your Handler when you instantiate the Handler;
Make all references to members of the outer class using the WeakReference object.&quot;
</code></pre><p>都是大白话，意思是：你应该将这个Handler设置为static的，否则可能导致内存泄露，原因呢是因为Handler会持有外部类引用，从而阻止了垃圾回收对外部类的回收，如果这个Handler的Looper关联的是子线程，那这个就没什么问题，但是如果Handler.Looper关联的是主线程，那么你就需要按照以下步骤调整一下了：将Handler申明为static,对于handler对于外部的引用使用WeakReference来持有.</p>
<p>我们来分析下为什么：</p>
<ol>
<li>为什么非静态的Handler会导致内存泄露？<br> 首先得明白什么是内存泄露，简单来讲：一个无用对象还有其他对象引用它，导致了GC不会去回收它，详情呢二哥给你推荐个<a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="external">关于Java内存泄露的文章</a><br> Handler作为一个内部类会持有外部类的引用（比如Activity），而Handler发出去的消息是异步的，不确定是什么时候执行，比如postDelay<br> 这样如果在这个消息已经发送但是还未执行的过程中，Activity已经finish了，垃圾回收是不会回收这个activity，这样就导致了内存泄露<br> 为什么不会回收呢，是因为此对象还有被其他对象引用，被谁引用呢？未执行的msg持有handler的引用(msg.target)，handler持有外部类activity的引用</li>
<li>为什么子线程没问题，主线程会有问题<br> 关于这个问题，我还没想清楚，目前能想到的就是主线程的Handler对应的Looper是一直循环不会结束的，但是实际上导致泄露的是msg.target.outerClassObj<br> 如果是子线程一样存在这个泄露的问题，还未想清楚，哪位高手给指条明路</li>
<li>为什么对外部的引用使用WeakReference就没问题了<br> WeakReference是相对于强引用的一个概念，在Java虚拟机在执行GC操作时候，如果一个对象仅仅是被弱引用的话，是会被回收的，这样就避免了上述的内存泄露</li>
<li>那么具体怎么解决呢？<br> as Follows:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> SafeHandler handler = <span class="keyword">new</span> SafeHandler(<span class="keyword">this</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Activity&gt; mActivity;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SafeHandler</span><span class="params">(Activity activity)</span></span>&#123;</div><div class="line">    mActivity = <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当然，可以将SafeHandler作为一个通用类，在需要时候直接new SafeHandler来覆写handleMessage</p>

    
    </div>
    
</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-WHY-HOW-WHEN" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/07/16/WHY-HOW-WHEN/">WHY？HOW? WHEN?</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-07-16T07:12:05.000Z" itemprop="datePublished" class="post-time">
  2016-07-16
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <p>WHY ? 为什么要写</p>
<pre><code>1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚
2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维
3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西
</code></pre><p>HOW ? 怎样写</p>
<pre><code>1. 为了解决什么问题
2. 具体是怎么去解决此问题的
3. 有哪些相似的方案，优劣如何
4. 具体的应用场景
5. 思考
6. 原创
</code></pre><p>WHEN ? 什么时候写</p>
<pre><code>目标可达，就要求有具体的时间，不然没法衡量
对于这里的技术文章，&lt;font color=red&gt;每周写一篇&lt;/font&gt;
</code></pre>
    
    </div>
    
</article>
    </li>
  
</ul>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Terge's Android Life",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://terge.me/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>







<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80738215-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



</body>
</html>
