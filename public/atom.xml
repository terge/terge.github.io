<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terge&#39;s Android Life</title>
  <subtitle>主动、无畏、习惯、沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://terge.me/"/>
  <updated>2016-07-26T00:24:58.000Z</updated>
  <id>http://terge.me/</id>
  
  <author>
    <name>唐自刚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说一下Handler的原理</title>
    <link href="http://terge.me/2016/07/16/%E8%AF%B4%E4%B8%80%E4%B8%8BHandler%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://terge.me/2016/07/16/说一下Handler的原理/</id>
    <published>2016-07-16T07:33:31.000Z</published>
    <updated>2016-07-26T00:24:58.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Part1-Handler原理概述&quot;&gt;&lt;a href=&quot;#Part1-Handler原理概述&quot; class=&quot;headerlink&quot; title=&quot;Part1 : Handler原理概述&quot;&gt;&lt;/a&gt;Part1 : Handler原理概述&lt;/h2&gt;&lt;h4 id=&quot;Handler在解决什么问题&quot;&gt;&lt;a href=&quot;#Handler在解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;Handler在解决什么问题?&quot;&gt;&lt;/a&gt;Handler在解决什么问题?&lt;/h4&gt;&lt;p&gt;handler 是为了解决线程间通讯的问题而设计的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 解决线程通讯一个通用的回调就可以，何必整真么多事出来
- handler给我们的印象是更新UI用的，如何与线程通讯联系起来
- 仅仅是线程通讯么？如果要通知的线程已经执行完任务销毁了呢？又如果，他自己在处理其他事情，没空理你呢？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线程通讯回调:handler.sendMessageAt()&lt;br&gt;为什么用来更新UI，大多数情况我们是用来是子线程来通知主线程来操作的，所以造成了这么个印象&lt;br&gt;为了避免多个子线程与主线程通讯，造成的混乱，设计成队列处理，一个个排队来，处理完一个再有请下一位&lt;/p&gt;
&lt;h4 id=&quot;Handler提供了哪些API功能&quot;&gt;&lt;a href=&quot;#Handler提供了哪些API功能&quot; class=&quot;headerlink&quot; title=&quot;Handler提供了哪些API功能&quot;&gt;&lt;/a&gt;Handler提供了哪些API功能&lt;/h4&gt;&lt;p&gt;对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 发消息        sendMessageAt()
2. 处理消息      handleMessage()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里对应就有两个疑问了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 他的消息发给谁？
2. 消息又是由谁来消费的?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler&lt;br&gt;了解他们是如何协同工作的才能回答上述两个疑问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oaumghlfk.bkt.clouddn.com/handler.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;Handler-flow&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整体上ThreadA持有handler，发送的消息，只是将消息塞到ThreadB的Looper的MessageQueue中&lt;/li&gt;
&lt;li&gt;MessageQueue中的消息会被与之对应的Looper逐个取出来&lt;/li&gt;
&lt;li&gt;执行Looper中的消息的主体是与Looper对应的ThreadB&lt;/li&gt;
&lt;li&gt;ThreadB只是调用message.target.dispatchMessage&lt;/li&gt;
&lt;li&gt;这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.handlerMessage&lt;/li&gt;
&lt;li&gt;但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑是在ThreadB上执行的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,一个线程最多只有一个Looper&lt;/p&gt;
&lt;p&gt;再来回答那两个问题：&lt;br&gt;    Handler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中，而这个Looper对应的线程是哪一个，消息就会被那个线程消费&lt;/p&gt;
&lt;h2 id=&quot;Part2-源码分析&quot;&gt;&lt;a href=&quot;#Part2-源码分析&quot; class=&quot;headerlink&quot; title=&quot;Part2 : 源码分析&quot;&gt;&lt;/a&gt;Part2 : 源码分析&lt;/h2&gt;&lt;p&gt;以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Handler.sendMessageAtTime 最终将消息入队列&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sendMessageAtTime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; uptimeMillis)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MessageQueue queue = mQueue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (queue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        RuntimeException e = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot; sendMessageAtTime() called with no mQueue&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Log.w(&lt;span class=&quot;string&quot;&gt;&quot;Looper&quot;&lt;/span&gt;, e.getMessage(), e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; enqueueMessage(queue, msg, uptimeMillis);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继续看Handler.enqueueMessage&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enqueueMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MessageQueue queue, Message msg, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; uptimeMillis)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    msg.target = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mAsynchronous) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg.setAsynchronous(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; queue.enqueueMessage(msg, uptimeMillis);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;OK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)&lt;/p&gt;
&lt;p&gt;那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; MessageQueue mQueue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Looper mLooper;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Handler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Callback callback, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; async)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mLooper = Looper.myLooper();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mLooper == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mQueue = mLooper.mQueue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Handler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Looper looper, Callback callback, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; async)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mLooper = looper;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mQueue = looper.mQueue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;呐，我们熟悉的异常：&lt;br&gt;&lt;br&gt;&lt;em&gt;“Can’t create handler inside thread that has not called Looper.prepare()”&lt;/em&gt;&lt;br&gt;&lt;br&gt;Handler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看&lt;br&gt;上述的MQ就是Looper.mQueue&lt;br&gt;并且Looper和MQ都是final的，构造完之后就不可改变&lt;br&gt;到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//MessageQueue.enqueueMessage&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enqueueMessage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Message msg, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; when)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//这个target就是handler引用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (msg.target == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;string&quot;&gt;&quot;Message must have a target.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//消息不能重复使用，有需要记得clone一份&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (msg.isInUse()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(msg + &lt;span class=&quot;string&quot;&gt;&quot; This message is already in use.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//队列已经退出的逻辑处理&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//mQuitting状态标识是在MQ.quit()方法中被设为true的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mQuitting) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            IllegalStateException e = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    msg.target + &lt;span class=&quot;string&quot;&gt;&quot; sending message to a Handler on a dead thread&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Log.w(TAG, e.getMessage(), e);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            msg.recycle();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//消息是在这里设置成已经消费了&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg.markInUse();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//时间是在入队时候指定的，之前手动给消息赋时间没有意义&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg.when = when;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Message p = mMessages;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; needWake;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || when == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || when &amp;lt; p.when) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            msg.next = p;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            mMessages = msg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            needWake = mBlocked;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            needWake = mBlocked &amp;amp;&amp;amp; p.target == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; msg.isAsynchronous();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Message prev;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;//MQ中的消息是根据msg.when来排序的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;//根据msg.when给新来的Msg找个合适的位置插进去&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (;;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                prev = p;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                p = p.next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;//1. p == null，说明找到队列尾部了还是没找到合适位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;//2. when &amp;lt; p.when 说明找到一个比自己还要晚展示的消息&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || when &amp;lt; p.when) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (needWake &amp;amp;&amp;amp; p.isAsynchronous()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    needWake = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;//插入msg&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            msg.next = p; &lt;span class=&quot;comment&quot;&gt;// invariant: p == prev.next&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            prev.next = msg;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// We can assume mPtr != 0 because mQuitting is false.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (needWake) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            nativeWake(mPtr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;啥也不说了，都在酒里了，哦不，在注释里&lt;br&gt;上述也只是说了具体的Message入队的细节，还是没有将入队之后的事情&lt;br&gt;那接下来就要去MQ对应的Looper里面看了&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Lopper.loop()&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Looper me = myLooper();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (me == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; MessageQueue queue = me.mQueue;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Make sure the identity of this thread is that of the local process,&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// and keep track of what that identity token actually is.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Binder.clearCallingIdentity();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; ident = Binder.clearCallingIdentity();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (;;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Message msg = queue.next(); &lt;span class=&quot;comment&quot;&gt;// might block&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (msg == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// No message indicates that the message queue is quitting.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg.target.dispatchMessage(msg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        msg.recycleUnchecked();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到loop做的就是不停的取消息，然后调用msg.target.dispatchMessage(msg);&lt;/p&gt;
&lt;p&gt;loop这里有几点需要注意：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. loop方法是个死循环：for (;;) {}
2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（懒得说了，你自行看下就明白）
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Part3-扩展&quot;&gt;&lt;a href=&quot;#Part3-扩展&quot; class=&quot;headerlink&quot; title=&quot;Part3 扩展&quot;&gt;&lt;/a&gt;Part3 扩展&lt;/h2&gt;&lt;h4 id=&quot;Handler的消息发到哪里了&quot;&gt;&lt;a href=&quot;#Handler的消息发到哪里了&quot; class=&quot;headerlink&quot; title=&quot;Handler的消息发到哪里了&quot;&gt;&lt;/a&gt;Handler的消息发到哪里了&lt;/h4&gt;&lt;p&gt;handler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是一个消息，如果你愿意，完全可以Message.obtain(handler,runable)，再通过handler.sendMessage来发送runnable&lt;/p&gt;
&lt;p&gt;那么handler.sendMessageAt(msg,time) 的逻辑做的事情就是将msg入到消息队列里面去&lt;br&gt;queue.enqueueMessage(msg,time)&lt;/p&gt;
&lt;h4 id=&quot;ThreadLoacal是什么鬼&quot;&gt;&lt;a href=&quot;#ThreadLoacal是什么鬼&quot; class=&quot;headerlink&quot; title=&quot;ThreadLoacal是什么鬼&quot;&gt;&lt;/a&gt;ThreadLoacal是什么鬼&lt;/h4&gt;&lt;p&gt;每个讲Handler都要提到theadLocal,这个与主题没有一毛钱关系，将其理解成Thread一个Map就好，想详细了解的自行Google,个人觉得这东西与Handler原理扯不上关系&lt;/p&gt;
&lt;h4 id=&quot;MessageQueue是怎么组织的？BlockQueue&quot;&gt;&lt;a href=&quot;#MessageQueue是怎么组织的？BlockQueue&quot; class=&quot;headerlink&quot; title=&quot;MessageQueue是怎么组织的？BlockQueue?&quot;&gt;&lt;/a&gt;MessageQueue是怎么组织的？BlockQueue?&lt;/h4&gt;&lt;p&gt;具体的实现都在native中 ？暂且当做BlockQueue来理解//todo&lt;br&gt;enqueueMessage&lt;br&gt;异常情况(msg.target == null  || msg.isInUse() )&lt;br&gt;sendMessage会自动设置target,//什么场景下修改会为空？？&lt;br&gt;msg.isInUse会在入队列时候修改，所以在重复使用时候可以通过Message.obtain(msg)来客隆一份数据一样但是没有使用过的Message来使用&lt;br&gt;sendMessageAtFrontOfQueue&lt;/p&gt;
&lt;p&gt;此队列并非先进先出队列，而是一个LinkedQueue,在enqueueMessage,会根据Message.when，将其插入到合适的位置，队列中的消息是按照when排序的&lt;/p&gt;
&lt;h4 id=&quot;Message-when&quot;&gt;&lt;a href=&quot;#Message-when&quot; class=&quot;headerlink&quot; title=&quot;Message.when&quot;&gt;&lt;/a&gt;Message.when&lt;/h4&gt;&lt;p&gt;在发消息时候发送一个when 比 当期MessageQueue时间还小的when即可插队到对头，你也许会说，我哪里知道当前对头的消息when是多少，所以直接设置when为0即可插队到对头，这可以应用在优先级高的处理&lt;/p&gt;
&lt;p&gt;但是when可以修改么？&lt;br&gt;when是package访问权限(还好不是final)，是否可以通过新建一个与其包名相同的类来修改？&lt;br&gt;when值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，不要煞费苦心修改了，平时直接发送的sendMessage的when就是0&lt;br&gt;如果同时发送的消息如果都是0，还在排队处理的话，后来的消息会插在队列的前面，都是立即处理的话，处理谁都一样&lt;/p&gt;
&lt;h4 id=&quot;Message-target&quot;&gt;&lt;a href=&quot;#Message-target&quot; class=&quot;headerlink&quot; title=&quot;Message.target&quot;&gt;&lt;/a&gt;Message.target&lt;/h4&gt;&lt;p&gt;Handler.obtain系列会将Message.target赋值为this&lt;br&gt;而Handler.postRunnable 获取的Message没有赋值target&lt;br&gt;但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this&lt;br&gt;也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper&lt;/p&gt;
&lt;p&gt;但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中&lt;/p&gt;
&lt;h4 id=&quot;sendMessage与postRunable有什么区别&quot;&gt;&lt;a href=&quot;#sendMessage与postRunable有什么区别&quot; class=&quot;headerlink&quot; title=&quot;sendMessage与postRunable有什么区别&quot;&gt;&lt;/a&gt;sendMessage与postRunable有什么区别&lt;/h4&gt;&lt;p&gt;最终都是调用setMessageAt(msg,time),不同的是获取Message方式不同，postRunable是将unable赋值给message.callback&lt;/p&gt;
&lt;h2 id=&quot;Part4-思考&quot;&gt;&lt;a href=&quot;#Part4-思考&quot; class=&quot;headerlink&quot; title=&quot;Part4 思考&quot;&gt;&lt;/a&gt;Part4 思考&lt;/h2&gt;&lt;h4 id=&quot;如何停止Looper&quot;&gt;&lt;a href=&quot;#如何停止Looper&quot; class=&quot;headerlink&quot; title=&quot;如何停止Looper&quot;&gt;&lt;/a&gt;如何停止Looper&lt;/h4&gt;&lt;p&gt;Looper在loop的时候，如果取到一个Message为null，就会自行跳出，但是MessageQueue只有在队列为空和已经退出时候才会给Looper返回null. 不能通过发送null消息来停止，&lt;br&gt;同时Looper本身也提供了quite api来退出循环，原理是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束&lt;/p&gt;
&lt;p&gt;在Looper中会调用msg.target.dispatchMessage(msg),这样又将消息返回给handler来执行了，而此时消息执行是looper中调用的，也就是消息执行是在looper所在的线程调用的，这样此消息也就在此线程被消费&lt;br&gt;同时会调用msg.resycleUnchecked()回收此对象&lt;/p&gt;
&lt;h4 id=&quot;消息执行的优先级&quot;&gt;&lt;a href=&quot;#消息执行的优先级&quot; class=&quot;headerlink&quot; title=&quot;消息执行的优先级&quot;&gt;&lt;/a&gt;消息执行的优先级&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;会先处理msg.callback也（post进来的runnable就是设置到callback中）&lt;/li&gt;
&lt;li&gt;如果handler有设置callback，消息会发送到callback的handlermessge()中消费&lt;/li&gt;
&lt;li&gt;如果没设置就在本handler.handlerMessage()中消费&lt;/li&gt;
&lt;li&gt;而一般情况下我的处理逻辑都在handlerMessage中，这样消息就又回来了&lt;h4 id=&quot;聊一聊HandlerThread&quot;&gt;&lt;a href=&quot;#聊一聊HandlerThread&quot; class=&quot;headerlink&quot; title=&quot;聊一聊HandlerThread&quot;&gt;&lt;/a&gt;聊一聊HandlerThread&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/qq_23547831/article/details/50936584&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/qq_23547831/article/details/50936584&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;MainLooper-ActivityThread-man-如何做到一直待机&quot;&gt;&lt;a href=&quot;#MainLooper-ActivityThread-man-如何做到一直待机&quot; class=&quot;headerlink&quot; title=&quot;MainLooper ActivityThread.man() 如何做到一直待机&quot;&gt;&lt;/a&gt;MainLooper ActivityThread.man() 如何做到一直待机&lt;/h4&gt;&lt;h4 id=&quot;为什么框架层要提示防止内存泄露？因为Looper会一直循环&quot;&gt;&lt;a href=&quot;#为什么框架层要提示防止内存泄露？因为Looper会一直循环&quot; class=&quot;headerlink&quot; title=&quot;为什么框架层要提示防止内存泄露？因为Looper会一直循环&quot;&gt;&lt;/a&gt;为什么框架层要提示防止内存泄露？因为Looper会一直循环&lt;/h4&gt;&lt;h4 id=&quot;MessageQueue-的Barrier是什么鬼&quot;&gt;&lt;a href=&quot;#MessageQueue-的Barrier是什么鬼&quot; class=&quot;headerlink&quot; title=&quot;MessageQueue 的Barrier是什么鬼&quot;&gt;&lt;/a&gt;MessageQueue 的Barrier是什么鬼&lt;/h4&gt;&lt;h4 id=&quot;ActivityThread是个好东西&quot;&gt;&lt;a href=&quot;#ActivityThread是个好东西&quot; class=&quot;headerlink&quot; title=&quot;ActivityThread是个好东西&quot;&gt;&lt;/a&gt;ActivityThread是个好东西&lt;/h4&gt;&lt;p&gt;ActivityThread不是Thread&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Part1-Handler原理概述&quot;&gt;&lt;a href=&quot;#Part1-Handler原理概述&quot; class=&quot;headerlink&quot; title=&quot;Part1 : Handler原理概述&quot;&gt;&lt;/a&gt;Part1 : Handler原理概述&lt;/h2&gt;&lt;h4 id=&quot;H
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WHY？HOW? WHEN?</title>
    <link href="http://terge.me/2016/07/16/WHY-HOW-WHEN/"/>
    <id>http://terge.me/2016/07/16/WHY-HOW-WHEN/</id>
    <published>2016-07-16T07:12:05.000Z</published>
    <updated>2016-07-24T07:32:41.576Z</updated>
    
    <content type="html">&lt;p&gt;WHY ? 为什么要写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚
2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维
3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HOW ? 怎样写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 为了解决什么问题
2. 具体是怎么去解决此问题的
3. 有哪些相似的方案，优劣如何
4. 具体的应用场景
5. 思考
6. 原创
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;WHEN ? 什么时候写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;目标可达，就要求有具体的时间，不然没法衡量
对于这里的技术文章，&amp;lt;font color=red&amp;gt;每周写一篇&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;WHY ? 为什么要写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚
2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维
3. 知
    
    </summary>
    
    
  </entry>
  
</feed>
