{"meta":{"title":"Terge's Android Life","subtitle":"主动、无畏、习惯、沉淀","description":"description","author":"唐自刚","url":"http://terge.me"},"pages":[{"title":"tags","date":"2016-07-19T12:21:22.000Z","updated":"2016-07-24T07:32:41.576Z","comments":false,"path":"tags/index.html","permalink":"http://terge.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"说一下Handler的原理","slug":"说一下Handler的原理","date":"2016-07-16T07:33:31.000Z","updated":"2016-07-26T00:24:58.000Z","comments":true,"path":"2016/07/16/说一下Handler的原理/","link":"","permalink":"http://terge.me/2016/07/16/说一下Handler的原理/","excerpt":"","text":"Part1 : Handler原理概述Handler在解决什么问题?handler 是为了解决线程间通讯的问题而设计的 - 解决线程通讯一个通用的回调就可以，何必整真么多事出来 - handler给我们的印象是更新UI用的，如何与线程通讯联系起来 - 仅仅是线程通讯么？如果要通知的线程已经执行完任务销毁了呢？又如果，他自己在处理其他事情，没空理你呢？ 线程通讯回调:handler.sendMessageAt()为什么用来更新UI，大多数情况我们是用来是子线程来通知主线程来操作的，所以造成了这么个印象为了避免多个子线程与主线程通讯，造成的混乱，设计成队列处理，一个个排队来，处理完一个再有请下一位 Handler提供了哪些API功能对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了） 1. 发消息 sendMessageAt() 2. 处理消息 handleMessage() 这里对应就有两个疑问了: 1. 他的消息发给谁？ 2. 消息又是由谁来消费的? 看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler了解他们是如何协同工作的才能回答上述两个疑问 整体上ThreadA持有handler，发送的消息，只是将消息塞到ThreadB的Looper的MessageQueue中 MessageQueue中的消息会被与之对应的Looper逐个取出来 执行Looper中的消息的主体是与Looper对应的ThreadB ThreadB只是调用message.target.dispatchMessage 这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.handlerMessage 但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑是在ThreadB上执行的 他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,一个线程最多只有一个Looper 再来回答那两个问题： Handler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中，而这个Looper对应的线程是哪一个，消息就会被那个线程消费 Part2 : 源码分析以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭 1234567891011121314151617181920//Handler.sendMessageAtTime 最终将消息入队列public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;//继续看Handler.enqueueMessageprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; OK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time) 那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？ 1234567891011121314151617181920//Handlerfinal MessageQueue mQueue;final Looper mLooper;...public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; ...&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; ...&#125; 呐，我们熟悉的异常：“Can’t create handler inside thread that has not called Looper.prepare()”Handler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看上述的MQ就是Looper.mQueue并且Looper和MQ都是final的，构造完之后就不可改变到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//MessageQueue.enqueueMessageboolean enqueueMessage(Message msg, long when) &#123; //这个target就是handler引用 if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; //消息不能重复使用，有需要记得clone一份 if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; //队列已经退出的逻辑处理 //mQuitting状态标识是在MQ.quit()方法中被设为true的 if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; //消息是在这里设置成已经消费了 msg.markInUse(); //时间是在入队时候指定的，之前手动给消息赋时间没有意义 msg.when = when; Message p = mMessages; boolean needWake; //空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头 if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //MQ中的消息是根据msg.when来排序的 //根据msg.when给新来的Msg找个合适的位置插进去 for (;;) &#123; prev = p; p = p.next; //1. p == null，说明找到队列尾部了还是没找到合适位置 //2. when &lt; p.when 说明找到一个比自己还要晚展示的消息 if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //插入msg msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 啥也不说了，都在酒里了，哦不，在注释里上述也只是说了具体的Message入队的细节，还是没有将入队之后的事情那接下来就要去MQ对应的Looper里面看了 12345678910111213141516171819202122232425//Lopper.loop()public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... msg.target.dispatchMessage(msg); ... msg.recycleUnchecked(); &#125;&#125; 可以看到loop做的就是不停的取消息，然后调用msg.target.dispatchMessage(msg); loop这里有几点需要注意： 1. loop方法是个死循环：for (;;) {} 2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（懒得说了，你自行看下就明白） Part3 扩展Handler的消息发到哪里了handler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是一个消息，如果你愿意，完全可以Message.obtain(handler,runable)，再通过handler.sendMessage来发送runnable 那么handler.sendMessageAt(msg,time) 的逻辑做的事情就是将msg入到消息队列里面去queue.enqueueMessage(msg,time) ThreadLoacal是什么鬼每个讲Handler都要提到theadLocal,这个与主题没有一毛钱关系，将其理解成Thread一个Map就好，想详细了解的自行Google,个人觉得这东西与Handler原理扯不上关系 MessageQueue是怎么组织的？BlockQueue?具体的实现都在native中 ？暂且当做BlockQueue来理解//todoenqueueMessage异常情况(msg.target == null || msg.isInUse() )sendMessage会自动设置target,//什么场景下修改会为空？？msg.isInUse会在入队列时候修改，所以在重复使用时候可以通过Message.obtain(msg)来客隆一份数据一样但是没有使用过的Message来使用sendMessageAtFrontOfQueue 此队列并非先进先出队列，而是一个LinkedQueue,在enqueueMessage,会根据Message.when，将其插入到合适的位置，队列中的消息是按照when排序的 Message.when在发消息时候发送一个when 比 当期MessageQueue时间还小的when即可插队到对头，你也许会说，我哪里知道当前对头的消息when是多少，所以直接设置when为0即可插队到对头，这可以应用在优先级高的处理 但是when可以修改么？when是package访问权限(还好不是final)，是否可以通过新建一个与其包名相同的类来修改？when值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，不要煞费苦心修改了，平时直接发送的sendMessage的when就是0如果同时发送的消息如果都是0，还在排队处理的话，后来的消息会插在队列的前面，都是立即处理的话，处理谁都一样 Message.targetHandler.obtain系列会将Message.target赋值为this而Handler.postRunnable 获取的Message没有赋值target但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper 但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中 sendMessage与postRunable有什么区别最终都是调用setMessageAt(msg,time),不同的是获取Message方式不同，postRunable是将unable赋值给message.callback Part4 思考如何停止LooperLooper在loop的时候，如果取到一个Message为null，就会自行跳出，但是MessageQueue只有在队列为空和已经退出时候才会给Looper返回null. 不能通过发送null消息来停止，同时Looper本身也提供了quite api来退出循环，原理是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束 在Looper中会调用msg.target.dispatchMessage(msg),这样又将消息返回给handler来执行了，而此时消息执行是looper中调用的，也就是消息执行是在looper所在的线程调用的，这样此消息也就在此线程被消费同时会调用msg.resycleUnchecked()回收此对象 消息执行的优先级 会先处理msg.callback也（post进来的runnable就是设置到callback中） 如果handler有设置callback，消息会发送到callback的handlermessge()中消费 如果没设置就在本handler.handlerMessage()中消费 而一般情况下我的处理逻辑都在handlerMessage中，这样消息就又回来了聊一聊HandlerThread http://blog.csdn.net/qq_23547831/article/details/50936584 MainLooper ActivityThread.man() 如何做到一直待机为什么框架层要提示防止内存泄露？因为Looper会一直循环MessageQueue 的Barrier是什么鬼ActivityThread是个好东西ActivityThread不是Thread","categories":[],"tags":[]},{"title":"WHY？HOW? WHEN?","slug":"WHY-HOW-WHEN","date":"2016-07-16T07:12:05.000Z","updated":"2016-07-24T07:32:41.576Z","comments":true,"path":"2016/07/16/WHY-HOW-WHEN/","link":"","permalink":"http://terge.me/2016/07/16/WHY-HOW-WHEN/","excerpt":"","text":"WHY ? 为什么要写 1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚 2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维 3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西 HOW ? 怎样写 1. 为了解决什么问题 2. 具体是怎么去解决此问题的 3. 有哪些相似的方案，优劣如何 4. 具体的应用场景 5. 思考 6. 原创 WHEN ? 什么时候写 目标可达，就要求有具体的时间，不然没法衡量 对于这里的技术文章，&lt;font color=red&gt;每周写一篇&lt;/font&gt;","categories":[],"tags":[]}]}