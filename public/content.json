{"meta":{"title":"Terge's Android Life","subtitle":"主动、无畏、习惯、沉淀","description":"description","author":"唐自刚","url":"http://terge.me"},"pages":[{"title":"tags","date":"2016-07-19T12:21:22.000Z","updated":"2016-07-24T08:49:29.000Z","comments":false,"path":"tags/index.html","permalink":"http://terge.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"说一下Handler的原理","slug":"说一下Handler的原理","date":"2016-07-16T07:33:31.000Z","updated":"2016-07-28T00:11:23.000Z","comments":true,"path":"2016/07/16/说一下Handler的原理/","link":"","permalink":"http://terge.me/2016/07/16/说一下Handler的原理/","excerpt":"","text":"Part1 : Handler原理概述Handler在解决什么问题?“handler 是为了解决线程间通讯的问题而设计的” 对于这个回答我是不满意的： １．解决线程通讯一个通用的回调就可以，何必整真么多事出来 线程通讯是终极目的，在设计这个过程中还包括消息队列排队、循环读取消息、阻塞等待的逻辑 学习它如何优雅的设计这个通讯方案，是值得我们去深挖的 ２．handler给我们的印象是更新UI用的，如何与线程通讯联系起来 因为大多数情况我们是用来是子线程来通知主线程来操作的，而一般是通知主线程是更新UI 所以给我们造成这样一种误解：&quot;handler是更新UI&quot; 其实handler可以用来跟随意两个子线程通讯 Handler提供的接口handler主要提供这两个功能（其他一些功能都是围绕这两个转的） 1. 发消息 sendMessageAt() 2. 处理消息 handleMessage() 这里对应就有两个疑问了: 1. 它的消息发给谁？ 2. 消息又是由谁来消费的? 看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler了解他们是如何协同工作的才能回答上述两个疑问 ThreadA持有handler，此handler是使用线程B的Looper来实例化的，发送的消息是将其入队到ThreadB.Looper.MessageQueue中 MessageQueue中的消息会被与之对应的Looper逐个取出来 执行Looper中的消息的主体是与Looper对应的ThreadB ThreadB只是调用message.target.dispatchMessage 这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.dispatchMessage 但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑(也就是我们覆写的handlerMessage)是在ThreadB上执行的 他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,hander的消息就是入队到这个Looper的MQ中，一个线程最多只有一个Looper，线程会从Looper中取出消息来执行.我们一般使用Handler时候也是这样，在主线程实例化Handler，相当于使用主线程的Looper来实例化Handler,将此Handler的引用给到子线程，在需要时候子线程通过handler发消息，就会将消息入队到主线程的Looper中，从而在主线程中执行.主线程的Looper是在主线程实例化时候就已经准备好的，所以我们不需要调用Looper.prepare(),当我们需要子线程的Looper来实例化Handler的时候，就需要主动调用Looper.prepare(). 再来回答那两个问题： 它的消息发给谁？ Handler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中 消息又是由谁来消费的? 这个Looper对应的线程是哪一个，消息就会被那个线程消费 Part2 : 源码分析以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭 注意：Handler中所有的发消息接口如下图选中的postxxx和sendxxx 这些接口都只是在封装Message，最终都是调用到sendMessageAtTime，所以我们只看sendMessageAtTime即可 Handler.sendMessageAtTime()1234567891011121314151617181920//Handler.sendMessageAtTime 最终将消息入队列public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;//继续看Handler.enqueueMessageprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; OK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？ 1234567891011121314151617181920//Handlerfinal MessageQueue mQueue;final Looper mLooper;...public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; ...&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; ...&#125; 呐，还有我们熟悉的异常： &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot; Handler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看 所以出现此问题的处理方式：要么是直接传递Looper进来，要么是在实例化时候调用Looper.prepare(),然而Ｌooper.prepare()只能调用一次，如果已经prepare过了，再调用会抛异常,处理方式如下： 123if(Looper.myLooper() == null)&#123; Looper.prepare();&#125; Handler 在实例化时候就会初始化Looper和MQ上面Handler.sendMessage,msg最终是入到队列里了，这个MQ就是Looper.mQueue并且Looper和MQ都是final的，Handler构造完之后就不可改变到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑 MessageQueue.enqueueMessage()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//MessageQueue.enqueueMessageboolean enqueueMessage(Message msg, long when) &#123; //这个target就是handler引用 if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; //消息不能重复使用，有需要记得clone一份 if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; //队列已经退出的逻辑处理 //mQuitting状态标识是在MQ.quit()方法中被设为true的 if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; //消息是在这里设置成已经消费了 msg.markInUse(); //时间是在入队时候指定的，之前手动给消息赋时间没有意义 msg.when = when; Message p = mMessages; boolean needWake; //空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头 if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //MQ中的消息是根据msg.when来排序的 //根据msg.when给新来的Msg找个合适的位置插进去 for (;;) &#123; prev = p; p = p.next; //1. p == null，说明找到队列尾部了还是没找到合适位置 //2. when &lt; p.when 说明找到一个比自己还要晚展示的消息 if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //插入msg msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 啥也不说了，都在酒里了，哦不，在注释里上面说了具体的Message入队的细节，还是没有讲入队之后的事情那接下来就要去MQ对应的Looper里面看实现了 Lopper.loop()12345678910111213141516171819202122//Lopper.loop()public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; return; &#125; ... msg.target.dispatchMessage(msg); ... msg.recycleUnchecked(); &#125;&#125; Looper.loop执行逻辑是循环读取MQ中的mesage，然后执行message.target.dispatchMessage而这个message.target就是在enqueue时候制定的handler那，我们再跟踪到Handler.dispatchMessage去看看 Handler.dispatchMessage()1234567891011121314151617//Handler.dispatchMessagepublic void dispatchMessage(Message msg) &#123;//此处的msg.callback也就是postRunanable发送的runable if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; //注意这个mCallback不要与msg.callback混了 //这个是handler的callback.后面在讲HandlerThread时候会讲到这里 if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //呐，回到了我们覆写的handleMessage方法 handleMessage(msg); &#125;&#125; loop这里有几点需要注意： 1. loop方法是个死循环：for (;;) {} 2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（读者自行跟踪下，答对我送你一个惊喜） Part3 扩展ThreadLoacal是什么鬼市面上Handler都要提到theadLocal,如果我不提是不是显得我不够深入？将其理解成Thread一个Map就好，想深入了解的自行Google,个人觉得这与主题扯不上关系 Message.whenMQ是按照Message.when来进行排序的，消息入队时候会按照当前消息要展示的是事件来放到合适的位置，如果直接指定sendMessageAt的时间为０，就会直接放在队头，Handler提供的接口 sendMessage() postRunnable() sendMessageAtFrontOfQueue…这些都只是指定了sendMessageAt(msg,0),这个时间０就会赋值给message.when 但是when可以修改么？when是package访问权限(还好不是final)，可以通过新建一个与其包名相同的类来修改？when值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，入队之后这个值就没有意义了，所以我们修改它也没有意义 Message.targetHandler.obtain系列会将Message.target赋值为this而Handler.postRunnable 获取的Message没有赋值target但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中 sendMessage与postRunable有什么区别handler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是发送一个消息 如果你愿意，完全可以实例化一个Ｍessage，将runable赋值给msg.callback，再通过handler.sendMessage来发送runnable注:这种方式可以用于统一处理，比如switch-case中，有的case是sendMessage,有的是postRunanable,这样就可以在case里面只处理Message，对于postRunanable的情况也使用message来处理，在switch-case的外层统一调用sendMessage来发送 Handler消费消息时候处理的优先顺序Handler处理消息是按如下顺序来处理的msg.callback –&gt; handler.callback –&gt; handler.handlerMessage(msg)如果设置了msg.callback,那么会优先处理，此时对其设置的msg.what 和msg.obj都是没有意义的handler.callback一般我们不会设置，后续理解HandlerThread会讲到，如果设置了handler.callback，那么消息也不会进入handlerMessage里面的最后才是使用handler.handlerMessage来消费此消息 如何停止LooperLooper在loop的时候，如果取到一个Message为null，就会自行跳出，只有在MQ为空或者MQ已经退出了才会给Looper返回null. 但不能通过发送null消息来停止调用Looper.quit()可以停止Looper，实际上是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束 聊一聊HandlerThread本来想一起写的，发现这一主题也可以写很多东西出来，后面会单独写一篇来梳理HandlerThread 为什么框架层要提示防止内存泄露？我们在使用Handler时候，如果直接在主线程实例化一个线程，会有如下警告提示： &quot;This Handler class should be static or leaks might occur . Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.&quot; 都是大白话，意思是：你应该将这个Handler设置为static的，否则可能导致内存泄露，原因呢是因为Handler会持有外部类引用，从而阻止了垃圾回收对外部类的回收，如果这个Handler的Looper关联的是子线程，那这个就没什么问题，但是如果Handler.Looper关联的是主线程，那么你就需要按照以下步骤调整一下了：将Handler申明为static,对于handler对于外部的引用使用WeakReference来持有. 我们来分析下为什么： 为什么非静态的Handler会导致内存泄露？ 为什么子线程没问题，主线程会有问题 为什么对外部的引用使用WeakReference就没问题了 那么具体怎么解决呢？","categories":[],"tags":[]},{"title":"WHY？HOW? WHEN?","slug":"WHY-HOW-WHEN","date":"2016-07-16T07:12:05.000Z","updated":"2016-07-24T08:49:29.000Z","comments":true,"path":"2016/07/16/WHY-HOW-WHEN/","link":"","permalink":"http://terge.me/2016/07/16/WHY-HOW-WHEN/","excerpt":"","text":"WHY ? 为什么要写 1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚 2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维 3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西 HOW ? 怎样写 1. 为了解决什么问题 2. 具体是怎么去解决此问题的 3. 有哪些相似的方案，优劣如何 4. 具体的应用场景 5. 思考 6. 原创 WHEN ? 什么时候写 目标可达，就要求有具体的时间，不然没法衡量 对于这里的技术文章，&lt;font color=red&gt;每周写一篇&lt;/font&gt;","categories":[],"tags":[]}]}