{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/logo.jpg","path":"img/logo.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/indigo/README.md","hash":"7da26382b8544a4d5d4acc39e789c9eacc816163","modified":1468930795155},{"_id":"source/favicon.ico","hash":"7b6a717524fcaf10b84f2252c8941aa2a6342d00","modified":1469345561576},{"_id":"themes/indigo/_config.yml","hash":"632e5dea9a8790d3fe1dfe9b8d3cbd65af62a54d","modified":1469174294571},{"_id":"themes/indigo/package.json","hash":"16b1325b2ef6cd72b0b02c4a66cc4c0d85fa3513","modified":1468930795155},{"_id":"source/_drafts/Android面试题整理.md","hash":"040d5f3c199a79331b8558b49d575a7a90409769","modified":1469345561576},{"_id":"source/_drafts/Binder是怎样达到进程间通讯的.md","hash":"6ad43464eb658c4c4152bab789b54c4ad20f2e30","modified":1469345561576},{"_id":"source/_drafts/JAVA虚拟机是如何做内存管理的.md","hash":"8dc920d4ee377772785185a9abd69dd8b9889b99","modified":1469345561576},{"_id":"source/_drafts/MarkDown语法参考.md","hash":"c139f2bacf869217931a5d8846abf472caafc5f1","modified":1469345561576},{"_id":"source/_drafts/如何使用官方测试框架Espresso.md","hash":"4705220d9b6f68c4f845e2dfbf68f71baaf21174","modified":1469412452036},{"_id":"source/_drafts/View的事件分发是怎样的.md","hash":"679a2aa2d50a57df64b3d510d066dea0fd995589","modified":1469361959414},{"_id":"source/_drafts/为什么离职.md","hash":"2629e73eb7c3192f7a8808f9147c2b06c2174149","modified":1469345561576},{"_id":"source/_drafts/你是如何理解AIDL的.md","hash":"fa08359823ceb310ff5d7347c1c2e46c87766723","modified":1469345561576},{"_id":"source/_drafts/如何在webview实现全屏播放视频.md","hash":"14765f8fa7fdfb2cdb5ca0c63f8477e3935d9670","modified":1469345561576},{"_id":"source/_drafts/如何实现webview上传本地图片.md","hash":"4a1580c8a3e5edd9ea2e0ddd2b2fe9aaf56a72e0","modified":1469345561576},{"_id":"source/_drafts/如何理解MVVM模式.md","hash":"e998fe2b70dde0201ad7c6565c768b591907a877","modified":1469345561576},{"_id":"source/_drafts/对自己的职业规划是怎样的.md","hash":"f8c710bdbf367b1b8a35cbefbbd2ee4e00f931f1","modified":1469345561576},{"_id":"source/_drafts/怎么理解RESTfull-API.md","hash":"2bf212326256748bbadbc62b11c9a20ce1b0ead3","modified":1469345561576},{"_id":"source/_drafts/怎样做Android的性能优化.md","hash":"b1309d7e796b3af30afa11d8ae26907a74878986","modified":1469345561576},{"_id":"source/_drafts/现在产品中哪些做得好的和不足的地方.md","hash":"367f9315bb8ad62ab25bcea877c06e1073043dd6","modified":1469345561576},{"_id":"source/_drafts/聊下Android的适配.md","hash":"331cb47c31bfb26648892a6a60c7812b9cfc88ab","modified":1469345561576},{"_id":"source/_drafts/聊聊API里面使用的算法.md","hash":"4e96b5818af45f4d0bff0ac2b5dcfc8920afb581","modified":1469345561576},{"_id":"source/_drafts/聊聊Android的启动模式.md","hash":"69ea1d4f55f5f5b665b32a4514a08354c54ad792","modified":1469345561576},{"_id":"source/_drafts/聊聊JAVA的同步机制.md","hash":"5b593f933b90261cada91f8de40dc33242695573","modified":1469345561576},{"_id":"source/_drafts/自行实现常用数据结构.md","hash":"c6935b2f8509bf4f6cf5aaa7e7d7e90edd77cc59","modified":1469345561576},{"_id":"source/_drafts/说下对ActivityThread的理解.md","hash":"907525a678f1ca2fc52eeae07e4be023f5daee78","modified":1469412452036},{"_id":"source/_drafts/说下Android-View的绘图原理.md","hash":"a3f912062a77d87aebaa43062cf740cdaa120edc","modified":1469345561576},{"_id":"source/_drafts/说下WindowManager的原理.md","hash":"5bc60abd1e60f7ae3e67870b0b808d19e5008d55","modified":1469345561576},{"_id":"source/_drafts/说下动画的实现原理.md","hash":"b5ba8d6cd9ffb4c48ab9a4fe63925a0282e4e6df","modified":1469345561576},{"_id":"source/_drafts/说下对Thread的理解.md","hash":"7c344cbc3b1910e785969fdf8262a758f969f5f2","modified":1469345561576},{"_id":"source/_posts/说一下Handler的原理.md","hash":"7e5056205b8a1a41d5698b95738e446572f24161","modified":1469492698000},{"_id":"source/_drafts/说下现在做的SDK的整体架构.md","hash":"832afd788a116c714f86da81033e42455312c6e7","modified":1469345561576},{"_id":"source/_drafts/说说你的ClassLoader的理解.md","hash":"b842060b70459b924a6d4e34b03ab88b248bba16","modified":1469345561576},{"_id":"source/_posts/WHY-HOW-WHEN.md","hash":"aa2d4bcac51135aadba4732c76db50cf52f15873","modified":1469345561576},{"_id":"source/tags/index.md","hash":"c6d5549c5a63e3bdf596bd75e9018f3565712d4a","modified":1469345561576},{"_id":"themes/indigo/layout/archive.ejs","hash":"21bfd12209615796b16bf794df75fc857a19b32c","modified":1468930795155},{"_id":"themes/indigo/layout/category.ejs","hash":"183ec4632c44243db391b1722aec485073417690","modified":1468930795155},{"_id":"themes/indigo/layout/index.ejs","hash":"9a3b3d88f4992d20c082383e3155e9e3bc9b6409","modified":1468930795155},{"_id":"themes/indigo/layout/layout.ejs","hash":"fc36f206a97bf65eacead631a0dbf043dcf356ac","modified":1468930795155},{"_id":"themes/indigo/layout/page.ejs","hash":"26c42241ae442942fa78e22c99b7ee7debe512e4","modified":1468930795155},{"_id":"themes/indigo/layout/post.ejs","hash":"26c42241ae442942fa78e22c99b7ee7debe512e4","modified":1468930795155},{"_id":"themes/indigo/layout/tag.ejs","hash":"183ec4632c44243db391b1722aec485073417690","modified":1468930795155},{"_id":"themes/indigo/layout/tags.ejs","hash":"91e94dcd997acb71ac688993715390c7e48b89c1","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"51cf12c71469b3db65828b672b46cc7071974bda","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"3b160eaaefb7a493d9dc96c932f06f0ee2772f7d","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/cnzz.ejs","hash":"03f75c55cb78686603a430fa42c63805872fb902","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/google-analytics.ejs","hash":"3e21a04d31e7d6481c6460f2a6ac48448cfaea5f","modified":1468931385998},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"912aed381f0b6f5ff7adfa18bfae617d5a6f06be","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"bba8497d29f405e8e6d1c8674fe7fc8f2a42cbb2","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"4c104599e23d77e91f2bd79d0ae9cdafe952cb01","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"5761c6cceafd683773f78ee01ec2c92cb585cca4","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/mathjax.ejs","hash":"c3394a1257a4f2cf30644016d9dc43e3a44d61dc","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"af06ecb670125aa51bf0bc1acba0dc1129793389","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"1253621c13936ca0f9fcafa7fd35d6f7ddc600b6","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"73ae079958f2cdc746b259fa1d0857002aa44267","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"1c8e7a1d512f4b81431f03eb80b0b331229799bb","modified":1468930795155},{"_id":"themes/indigo/source/css/style.less","hash":"bc2bcbf43091599ab63edc79413f9d08e8fb061f","modified":1468930795171},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1468930795171},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1468930795171},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1468930795171},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1468930795171},{"_id":"themes/indigo/source/img/logo.jpg","hash":"9d85d200dc96463e751bc7dbad8f0687b38fe490","modified":1467868589404},{"_id":"themes/indigo/source/js/main.js","hash":"e3ccf70da521a03a581b1dd23b0cbea9b4f023a9","modified":1468930795171},{"_id":"themes/indigo/source/js/search.js","hash":"55f55e48d7080b69416bae449d6ab59d5af79695","modified":1468930795171},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"41bef893d2f6569a8319b968936184f19475da40","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"528490c368d92266b6a8ea3ecab5c0f42877bac3","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"6c359ca773dee87ecf7a1553a31a9418c900583a","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"6b2ab0a9a67732ba18bc8520f0ff6805457bb427","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"33181dbf9c126b3354a2e6a83605c40674b222b7","modified":1468930795155},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1468930795155},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"69180b54d5d9aa460e67a245e8537fdd0b6d0640","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"f078270dfe0a3f1757ec20598a6d05448bf4b151","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"bf9c09de9a989cf597ca78e78240f8496dbca4f8","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"a43d79dee0f667d85bcddee23ad43e736e133ee3","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"3bf77e233d6d8fb1e0ecf394a10a6694a8e39660","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"c32656b8d51fca9b3bfa95f1aa44b51ade203e18","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"c4b080ea12670c3bbb15fa85e5a66f109fba3389","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"d73a12ca56cd710a13cb61074958c82a5cb95d63","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"dc26e274703827cb28b6c9beff53b4176cdce783","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"6a256bfa57547ede5e05dfa61878f582780db6ad","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"da574cf0ad43c32dd24da6906bfc4f6c1054e07b","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"61019c991dff98a380314b88c6f875d693c3e7e1","modified":1468930795159},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"9d9b1946357a653adebc29859ad0de70adcc27dd","modified":1468930795159},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1468930795163},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1468930795159},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1468930795159},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1468930795163},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1468930795163},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1468930795167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1468930795171},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1468930795163},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1468930795163},{"_id":"public/atom.xml","hash":"51089f1e7a87951c10490d8093bdfaf23233d84a","modified":1469492792410},{"_id":"public/content.json","hash":"7862e9eb6f688e98c4d7193814a0c3065447c052","modified":1469492792458},{"_id":"public/tags/index.html","hash":"170669795a276d7c4c16fd5c6720b194dbcec518","modified":1469414209428},{"_id":"public/2016/07/16/WHY-HOW-WHEN/index.html","hash":"cc22fea7051b765f11c05e34d0e6c832da7ae489","modified":1469414209428},{"_id":"public/archives/index.html","hash":"3b795bdd58f34a440892b15a88c9a693805ce7a5","modified":1469414209428},{"_id":"public/archives/2016/index.html","hash":"42f5066594f360e4fb2cfa98f956de9677802eb6","modified":1469414209428},{"_id":"public/archives/2016/07/index.html","hash":"520a213b737fe8c6a538275fbcb60525555f7a21","modified":1469414209428},{"_id":"public/2016/07/16/说一下Handler的原理/index.html","hash":"d5a13bfe6a47f9050ccf30ff2cbcca0fec17d060","modified":1469492792461},{"_id":"public/index.html","hash":"835eb8becae9fb7f01cf67aa75e817eaafe35299","modified":1469492792462},{"_id":"public/favicon.ico","hash":"7b6a717524fcaf10b84f2252c8941aa2a6342d00","modified":1469414209442},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1469414209442},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1469414209442},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1469414209442},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1469414209442},{"_id":"public/img/logo.jpg","hash":"9d85d200dc96463e751bc7dbad8f0687b38fe490","modified":1469414209442},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1469414209442},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1469414209442},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1469414209442},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1469414209443},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1469414209444},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1469414209444},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1469414209444},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1469414209470},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1469414209470},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1469414209471},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1469414209471},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1469414209471},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1469414209471},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1469414209471},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1469414209471},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1469414209471},{"_id":"public/js/main.js","hash":"e3ccf70da521a03a581b1dd23b0cbea9b4f023a9","modified":1469414209474},{"_id":"public/js/search.js","hash":"55f55e48d7080b69416bae449d6ab59d5af79695","modified":1469414209474},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1469414209474},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1469414209479},{"_id":"public/css/style.css","hash":"d17b88176b67c957c4a50be3991a3893e610b74d","modified":1469414209744},{"_id":"source/.DS_Store","hash":"6974ddb0953597b845d10c3aec9016f9ed161fbb","modified":1469363293000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1469406529000}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2016-07-19T12:21:22.000Z","layout":"tags","noDate":true,"comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-07-19 20:21:22\nlayout: tags\nnoDate: true\ncomments: false\n---\n","updated":"2016-07-24T07:32:41.576Z","path":"tags/index.html","_id":"cir1fa40a00012k22jvqzetbb","content":"","excerpt":"","more":""}],"Post":[{"title":"Binder是怎样达到进程间通讯的","_content":"","source":"_drafts/Binder是怎样达到进程间通讯的.md","raw":"---\ntitle: Binder是怎样达到进程间通讯的\ntags:\n---\n","slug":"Binder是怎样达到进程间通讯的","published":0,"date":"2016-07-24T08:06:58.950Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40500002k220grti8b5","content":"","excerpt":"","more":""},{"title":"Android面试题整理","_content":"\n- https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md\n- http://www.diycode.cc/wiki/androidinterview\n","source":"_drafts/Android面试题整理.md","raw":"---\ntitle: Android面试题整理\ntags:\n---\n\n- https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md\n- http://www.diycode.cc/wiki/androidinterview\n","slug":"Android面试题整理","published":0,"date":"2016-07-24T08:06:58.950Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40c00022k22h97mbx2h","content":"<ul>\n<li><a href=\"https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md\" target=\"_blank\" rel=\"external\">https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md</a></li>\n<li><a href=\"http://www.diycode.cc/wiki/androidinterview\" target=\"_blank\" rel=\"external\">http://www.diycode.cc/wiki/androidinterview</a></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><a href=\"https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md\">https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md</a></li>\n<li><a href=\"http://www.diycode.cc/wiki/androidinterview\">http://www.diycode.cc/wiki/androidinterview</a></li>\n</ul>\n"},{"title":"JAVA虚拟机是如何做内存管理的","_content":"","source":"_drafts/JAVA虚拟机是如何做内存管理的.md","raw":"---\ntitle: JAVA虚拟机是如何做内存管理的\ntags:\n---\n","slug":"JAVA虚拟机是如何做内存管理的","published":0,"date":"2016-07-24T08:06:58.954Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40e00032k22bmluqunm","content":"","excerpt":"","more":""},{"title":"MarkDown语法参考","_content":"","source":"_drafts/MarkDown语法参考.md","raw":"---\ntitle: MarkDown语法参考\ntags:\n---\n","slug":"MarkDown语法参考","published":0,"date":"2016-07-24T08:06:58.954Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40g00042k22161btrbt","content":"","excerpt":"","more":""},{"title":"如何使用官方测试框架Espresso","_content":"","source":"_drafts/如何使用官方测试框架Espresso.md","raw":"---\ntitle: 如何使用官方测试框架Espresso\ntags:\n---\n","slug":"如何使用官方测试框架Espresso","published":0,"date":"2016-07-25T02:07:32.036Z","updated":"2016-07-25T02:07:32.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40i00052k22534xsugp","content":"","excerpt":"","more":""},{"title":"View的事件分发是怎样的","_content":"\n\nhttp://www.jianshu.com/p/2be492c1df96\n","source":"_drafts/View的事件分发是怎样的.md","raw":"---\ntitle: View的事件分发是怎样的\ntags:\n---\n\n\nhttp://www.jianshu.com/p/2be492c1df96\n","slug":"View的事件分发是怎样的","published":0,"date":"2016-07-24T12:05:59.414Z","updated":"2016-07-24T12:05:59.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40l00062k22xfcvavk1","content":"<p><a href=\"http://www.jianshu.com/p/2be492c1df96\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/2be492c1df96</a></p>\n","excerpt":"","more":"<p><a href=\"http://www.jianshu.com/p/2be492c1df96\">http://www.jianshu.com/p/2be492c1df96</a></p>\n"},{"title":"为什么离职","_content":"","source":"_drafts/为什么离职.md","raw":"---\ntitle: 为什么离职\ntags:\n---\n","slug":"为什么离职","published":0,"date":"2016-07-24T08:06:58.958Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40o00072k22juvg909o","content":"","excerpt":"","more":""},{"title":"你是如何理解AIDL的","_content":"\n- http://blog.csdn.net/luoyanglizi/article/details/51958091\n- http://blog.csdn.net/luoyanglizi/article/details/51980630\n","source":"_drafts/你是如何理解AIDL的.md","raw":"---\ntitle: 你是如何理解AIDL的\ntags:\n---\n\n- http://blog.csdn.net/luoyanglizi/article/details/51958091\n- http://blog.csdn.net/luoyanglizi/article/details/51980630\n","slug":"你是如何理解AIDL的","published":0,"date":"2016-07-24T08:06:58.962Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40r00082k2287u2j11v","content":"<ul>\n<li><a href=\"http://blog.csdn.net/luoyanglizi/article/details/51958091\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luoyanglizi/article/details/51958091</a></li>\n<li><a href=\"http://blog.csdn.net/luoyanglizi/article/details/51980630\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luoyanglizi/article/details/51980630</a></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><a href=\"http://blog.csdn.net/luoyanglizi/article/details/51958091\">http://blog.csdn.net/luoyanglizi/article/details/51958091</a></li>\n<li><a href=\"http://blog.csdn.net/luoyanglizi/article/details/51980630\">http://blog.csdn.net/luoyanglizi/article/details/51980630</a></li>\n</ul>\n"},{"title":"如何在webview实现全屏播放视频","_content":"","source":"_drafts/如何在webview实现全屏播放视频.md","raw":"---\ntitle: 如何在webview实现全屏播放视频\ntags:\n---\n","slug":"如何在webview实现全屏播放视频","published":0,"date":"2016-07-24T08:06:58.962Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40u00092k22cs2rpv1a","content":"","excerpt":"","more":""},{"title":"如何实现webview上传本地图片","_content":"","source":"_drafts/如何实现webview上传本地图片.md","raw":"---\ntitle: 如何实现webview上传本地图片\ntags:\n---\n","slug":"如何实现webview上传本地图片","published":0,"date":"2016-07-24T08:06:58.962Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40w000a2k22k2d8mt8l","content":"","excerpt":"","more":""},{"title":"如何理解MVVM模式","_content":"- http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/\n","source":"_drafts/如何理解MVVM模式.md","raw":"---\ntitle: 如何理解MVVM模式\ntags:\n---\n- http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/\n","slug":"如何理解MVVM模式","published":0,"date":"2016-07-24T08:06:58.966Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa40z000b2k2263alxo4x","content":"<ul>\n<li><a href=\"http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/\" target=\"_blank\" rel=\"external\">http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/</a></li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><a href=\"http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/\">http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/</a></li>\n</ul>\n"},{"title":"对自己的职业规划是怎样的","_content":"","source":"_drafts/对自己的职业规划是怎样的.md","raw":"---\ntitle: 对自己的职业规划是怎样的\ntags:\n---\n","slug":"对自己的职业规划是怎样的","published":0,"date":"2016-07-24T08:06:58.966Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa411000c2k22a2jholfz","content":"","excerpt":"","more":""},{"title":"怎么理解RESTfull API","_content":"","source":"_drafts/怎么理解RESTfull-API.md","raw":"---\ntitle: 怎么理解RESTfull API\ntags:\n---\n","slug":"怎么理解RESTfull-API","published":0,"date":"2016-07-24T08:06:58.970Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa412000d2k22e73kk5x7","content":"","excerpt":"","more":""},{"title":"怎样做Android的性能优化","_content":"","source":"_drafts/怎样做Android的性能优化.md","raw":"---\ntitle: 怎样做Android的性能优化\ntags:\n---\n","slug":"怎样做Android的性能优化","published":0,"date":"2016-07-24T08:06:58.970Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa414000e2k222crvau9r","content":"","excerpt":"","more":""},{"title":"现在产品中哪些做得好的和不足的地方","_content":"","source":"_drafts/现在产品中哪些做得好的和不足的地方.md","raw":"---\ntitle: 现在产品中哪些做得好的和不足的地方\ntags:\n---\n","slug":"现在产品中哪些做得好的和不足的地方","published":0,"date":"2016-07-24T08:06:58.970Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa415000f2k22fjcjqkef","content":"","excerpt":"","more":""},{"title":"聊下Android的适配","_content":"","source":"_drafts/聊下Android的适配.md","raw":"---\ntitle: 聊下Android的适配\ntags:\n---\n","slug":"聊下Android的适配","published":0,"date":"2016-07-24T08:06:58.974Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa416000g2k22jvpfxarr","content":"","excerpt":"","more":""},{"layout":"dfaft","title":"聊聊API里面使用的算法","date":"2016-07-16T10:33:02.000Z","_content":"","source":"_drafts/聊聊API里面使用的算法.md","raw":"layout: dfaft\ntitle: 聊聊API里面使用的算法\ndate: 2016-07-16 18:33:02\ntags:\n---\n","slug":"聊聊API里面使用的算法","published":0,"updated":"2016-07-24T07:32:41.576Z","comments":1,"photos":[],"link":"","_id":"cir1fa419000h2k22en3n71b8","content":"","excerpt":"","more":""},{"title":"聊聊Android的启动模式","_content":"1. task 返回栈\n2. 案例：ProxyActivity会被游戏Activity的singleTask清掉\n3. 解决方案：CP不愿意改ａ.用一个单独的启动页面　　b.不使用new task，使其在一个task里面\n","source":"_drafts/聊聊Android的启动模式.md","raw":"---\ntitle: 聊聊Android的启动模式\ntags:\n---\n1. task 返回栈\n2. 案例：ProxyActivity会被游戏Activity的singleTask清掉\n3. 解决方案：CP不愿意改ａ.用一个单独的启动页面　　b.不使用new task，使其在一个task里面\n","slug":"聊聊Android的启动模式","published":0,"date":"2016-07-24T08:06:58.974Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41b000i2k222lqcttj0","content":"<ol>\n<li>task 返回栈</li>\n<li>案例：ProxyActivity会被游戏Activity的singleTask清掉</li>\n<li>解决方案：CP不愿意改ａ.用一个单独的启动页面　　b.不使用new task，使其在一个task里面</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li>task 返回栈</li>\n<li>案例：ProxyActivity会被游戏Activity的singleTask清掉</li>\n<li>解决方案：CP不愿意改ａ.用一个单独的启动页面　　b.不使用new task，使其在一个task里面</li>\n</ol>\n"},{"title":"聊聊JAVA的同步机制","_content":"","source":"_drafts/聊聊JAVA的同步机制.md","raw":"---\ntitle: 聊聊JAVA的同步机制\ntags:\n---\n","slug":"聊聊JAVA的同步机制","published":0,"date":"2016-07-24T08:06:58.978Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41c000j2k22yqzcsebg","content":"","excerpt":"","more":""},{"title":"自行实现常用数据结构","_content":"","source":"_drafts/自行实现常用数据结构.md","raw":"---\ntitle: 自行实现常用数据结构\ntags:\n---\n","slug":"自行实现常用数据结构","published":0,"date":"2016-07-24T08:06:58.978Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41d000k2k22ns3i9fzd","content":"","excerpt":"","more":""},{"title":"说下对ActivityThread的理解","_content":"","source":"_drafts/说下对ActivityThread的理解.md","raw":"---\ntitle: 说下对ActivityThread的理解\ntags:\n---\n","slug":"说下对ActivityThread的理解","published":0,"date":"2016-07-25T02:07:32.036Z","updated":"2016-07-25T02:07:32.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41e000l2k22z46b4vk4","content":"","excerpt":"","more":""},{"layout":"dfaft","title":"说下Android View的绘图原理","date":"2016-07-16T10:30:47.000Z","_content":"","source":"_drafts/说下Android-View的绘图原理.md","raw":"layout: dfaft\ntitle: 说下Android View的绘图原理\ndate: 2016-07-16 18:30:47\ntags:\n---\n","slug":"说下Android-View的绘图原理","published":0,"updated":"2016-07-24T07:32:41.576Z","comments":1,"photos":[],"link":"","_id":"cir1fa41g000m2k22h0rbi74c","content":"","excerpt":"","more":""},{"title":"说下WindowManager的原理","_content":"","source":"_drafts/说下WindowManager的原理.md","raw":"---\ntitle: 说下WindowManager的原理\ntags:\n---\n","slug":"说下WindowManager的原理","published":0,"date":"2016-07-24T08:06:58.982Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41h000n2k2266ouy0jm","content":"","excerpt":"","more":""},{"title":"说下动画的实现原理","_content":"","source":"_drafts/说下动画的实现原理.md","raw":"---\ntitle: 说下动画的实现原理\ntags:\n---\n","slug":"说下动画的实现原理","published":0,"date":"2016-07-24T08:06:58.982Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41i000o2k22s0hnck6b","content":"","excerpt":"","more":""},{"title":"说下对Thread的理解","_content":"","source":"_drafts/说下对Thread的理解.md","raw":"---\ntitle: 说下对Thread的理解\ntags:\n---\n","slug":"说下对Thread的理解","published":0,"date":"2016-07-24T08:06:58.982Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41l000p2k22qnwv83lw","content":"","excerpt":"","more":""},{"title":"说一下Handler的原理","date":"2016-07-16T07:33:31.000Z","_content":"\n## Part1 : Handler原理概述\n\n####  Handler在解决什么问题?\nhandler 是为了解决线程间通讯的问题而设计的\n\t- 解决线程通讯一个通用的回调就可以，何必整真么多事出来\n\t- handler给我们的印象是更新UI用的，如何与线程通讯联系起来\n\t- 仅仅是线程通讯么？如果要通知的线程已经执行完任务销毁了呢？又如果，他自己在处理其他事情，没空理你呢？\n\n\n线程通讯回调:handler.sendMessageAt()\n为什么用来更新UI，大多数情况我们是用来是子线程来通知主线程来操作的，所以造成了这么个印象\n为了避免多个子线程与主线程通讯，造成的混乱，设计成队列处理，一个个排队来，处理完一个再有请下一位\n\n\n####  Handler提供了哪些API功能\n对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了）\n\n\n    1. 发消息 \t   sendMessageAt()\n    2. 处理消息 \t handleMessage()\n\n这里对应就有两个疑问了:\n\n\t1. 他的消息发给谁？\n\t2. 消息又是由谁来消费的?\n\n看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler\n了解他们是如何协同工作的才能回答上述两个疑问\n\n![Handler-flow](http://oaumghlfk.bkt.clouddn.com/handler.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10)\n\n\n1. 整体上ThreadA持有handler，发送的消息，只是将消息塞到ThreadB的Looper的MessageQueue中\n2. MessageQueue中的消息会被与之对应的Looper逐个取出来\n3. 执行Looper中的消息的主体是与Looper对应的ThreadB\n4. ThreadB只是调用message.target.dispatchMessage\n5. 这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.handlerMessage\n6. 但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑是在ThreadB上执行的\n\n他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,一个线程最多只有一个Looper\n\n再来回答那两个问题：\n\tHandler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中，而这个Looper对应的线程是哪一个，消息就会被那个线程消费\n\n## Part2 : 源码分析\n以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭\n\n```java\n//Handler.sendMessageAtTime 最终将消息入队列\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\n//继续看Handler.enqueueMessage\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n\n```\nOK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)\n\n那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？\n\n```java\n//Handler\nfinal MessageQueue mQueue;\nfinal Looper mLooper;\n...\npublic Handler(Callback callback, boolean async) {\n\t\t...\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread that has not called Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    ...\n}\n\npublic Handler(Looper looper, Callback callback, boolean async) {\n    mLooper = looper;\n    mQueue = looper.mQueue;\n    ...\n}\n\n```\n呐，我们熟悉的异常：\n<br>*\"Can't create handler inside thread that has not called Looper.prepare()\"*</br>\nHandler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看\n上述的MQ就是Looper.mQueue\n并且Looper和MQ都是final的，构造完之后就不可改变\n到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑\n\n```java\n//MessageQueue.enqueueMessage\nboolean enqueueMessage(Message msg, long when) {\n\t\t//这个target就是handler引用\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n\t\t//消息不能重复使用，有需要记得clone一份\n    if (msg.isInUse()) {\n        throw new IllegalStateException(msg + \" This message is already in use.\");\n    }\n\n    synchronized (this) {\n\t\t//队列已经退出的逻辑处理\n\t\t//mQuitting状态标识是在MQ.quit()方法中被设为true的\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(TAG, e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\t\t//消息是在这里设置成已经消费了\n        msg.markInUse();\n\t\t//时间是在入队时候指定的，之前手动给消息赋时间没有意义\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n\t\t//空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头\n        if (p == null || when == 0 || when < p.when) {\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n\t\t\t//MQ中的消息是根据msg.when来排序的\n\t\t\t//根据msg.when给新来的Msg找个合适的位置插进去\n            for (;;) {\n                prev = p;\n                p = p.next;\n\t\t\t\t//1. p == null，说明找到队列尾部了还是没找到合适位置\n\t\t\t\t//2. when < p.when 说明找到一个比自己还要晚展示的消息\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n\t\t\t//插入msg\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n\n```\n啥也不说了，都在酒里了，哦不，在注释里\n上述也只是说了具体的Message入队的细节，还是没有将入队之后的事情\n那接下来就要去MQ对应的Looper里面看了\n\n```java\n//Lopper.loop()\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\t\t\t\t...\n        msg.target.dispatchMessage(msg);\n\t\t\t\t...\n        msg.recycleUnchecked();\n    }\n}\n\n\n```\n可以看到loop做的就是不停的取消息，然后调用msg.target.dispatchMessage(msg);\n\nloop这里有几点需要注意：\n\t1. loop方法是个死循环：for (;;) {}\n\t2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（懒得说了，你自行看下就明白）\n\n\n\n## Part3 扩展\n####  Handler的消息发到哪里了\nhandler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是一个消息，如果你愿意，完全可以Message.obtain(handler,runable)，再通过handler.sendMessage来发送runnable\n\n那么handler.sendMessageAt(msg,time) 的逻辑做的事情就是将msg入到消息队列里面去\nqueue.enqueueMessage(msg,time)\n\n####  ThreadLoacal是什么鬼\n每个讲Handler都要提到theadLocal,这个与主题没有一毛钱关系，将其理解成Thread一个Map就好，想详细了解的自行Google,个人觉得这东西与Handler原理扯不上关系\n\n####  MessageQueue是怎么组织的？BlockQueue?\n具体的实现都在native中 ？暂且当做BlockQueue来理解//todo\nenqueueMessage\n异常情况(msg.target == null  || msg.isInUse() )\nsendMessage会自动设置target,//什么场景下修改会为空？？\nmsg.isInUse会在入队列时候修改，所以在重复使用时候可以通过Message.obtain(msg)来客隆一份数据一样但是没有使用过的Message来使用\nsendMessageAtFrontOfQueue\n\n此队列并非先进先出队列，而是一个LinkedQueue,在enqueueMessage,会根据Message.when，将其插入到合适的位置，队列中的消息是按照when排序的\n\n\n####  Message.when\n在发消息时候发送一个when 比 当期MessageQueue时间还小的when即可插队到对头，你也许会说，我哪里知道当前对头的消息when是多少，所以直接设置when为0即可插队到对头，这可以应用在优先级高的处理\n\n但是when可以修改么？\nwhen是package访问权限(还好不是final)，是否可以通过新建一个与其包名相同的类来修改？\nwhen值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，不要煞费苦心修改了，平时直接发送的sendMessage的when就是0\n如果同时发送的消息如果都是0，还在排队处理的话，后来的消息会插在队列的前面，都是立即处理的话，处理谁都一样\n\n\n####  Message.target\nHandler.obtain系列会将Message.target赋值为this\n而Handler.postRunnable 获取的Message没有赋值target\n但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this\n也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper\n\n但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中\n\n\n####  sendMessage与postRunable有什么区别\n最终都是调用setMessageAt(msg,time),不同的是获取Message方式不同，postRunable是将unable赋值给message.callback\n\n\n\n\n## Part4 思考\n####  如何停止Looper\nLooper在loop的时候，如果取到一个Message为null，就会自行跳出，但是MessageQueue只有在队列为空和已经退出时候才会给Looper返回null. 不能通过发送null消息来停止，\n同时Looper本身也提供了quite api来退出循环，原理是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束\n\n在Looper中会调用msg.target.dispatchMessage(msg),这样又将消息返回给handler来执行了，而此时消息执行是looper中调用的，也就是消息执行是在looper所在的线程调用的，这样此消息也就在此线程被消费\n同时会调用msg.resycleUnchecked()回收此对象\n\n####  消息执行的优先级\n- 会先处理msg.callback也（post进来的runnable就是设置到callback中）\n- 如果handler有设置callback，消息会发送到callback的handlermessge()中消费\n- 如果没设置就在本handler.handlerMessage()中消费\n- 而一般情况下我的处理逻辑都在handlerMessage中，这样消息就又回来了\n####  聊一聊HandlerThread\n- http://blog.csdn.net/qq_23547831/article/details/50936584\n\n####  MainLooper ActivityThread.man() 如何做到一直待机\n\n\n####  为什么框架层要提示防止内存泄露？因为Looper会一直循环\n\n####  MessageQueue 的Barrier是什么鬼\n\n####  ActivityThread是个好东西\nActivityThread不是Thread\n","source":"_posts/说一下Handler的原理.md","raw":"---\ntitle: 说一下Handler的原理\ndate: 2016-07-16 15:33:31\ntags:\n---\n\n## Part1 : Handler原理概述\n\n####  Handler在解决什么问题?\nhandler 是为了解决线程间通讯的问题而设计的\n\t- 解决线程通讯一个通用的回调就可以，何必整真么多事出来\n\t- handler给我们的印象是更新UI用的，如何与线程通讯联系起来\n\t- 仅仅是线程通讯么？如果要通知的线程已经执行完任务销毁了呢？又如果，他自己在处理其他事情，没空理你呢？\n\n\n线程通讯回调:handler.sendMessageAt()\n为什么用来更新UI，大多数情况我们是用来是子线程来通知主线程来操作的，所以造成了这么个印象\n为了避免多个子线程与主线程通讯，造成的混乱，设计成队列处理，一个个排队来，处理完一个再有请下一位\n\n\n####  Handler提供了哪些API功能\n对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了）\n\n\n    1. 发消息 \t   sendMessageAt()\n    2. 处理消息 \t handleMessage()\n\n这里对应就有两个疑问了:\n\n\t1. 他的消息发给谁？\n\t2. 消息又是由谁来消费的?\n\n看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler\n了解他们是如何协同工作的才能回答上述两个疑问\n\n![Handler-flow](http://oaumghlfk.bkt.clouddn.com/handler.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10)\n\n\n1. 整体上ThreadA持有handler，发送的消息，只是将消息塞到ThreadB的Looper的MessageQueue中\n2. MessageQueue中的消息会被与之对应的Looper逐个取出来\n3. 执行Looper中的消息的主体是与Looper对应的ThreadB\n4. ThreadB只是调用message.target.dispatchMessage\n5. 这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.handlerMessage\n6. 但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑是在ThreadB上执行的\n\n他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,一个线程最多只有一个Looper\n\n再来回答那两个问题：\n\tHandler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中，而这个Looper对应的线程是哪一个，消息就会被那个线程消费\n\n## Part2 : 源码分析\n以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭\n\n```java\n//Handler.sendMessageAtTime 最终将消息入队列\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\n//继续看Handler.enqueueMessage\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {\n    msg.target = this;\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n\n```\nOK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)\n\n那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？\n\n```java\n//Handler\nfinal MessageQueue mQueue;\nfinal Looper mLooper;\n...\npublic Handler(Callback callback, boolean async) {\n\t\t...\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread that has not called Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    ...\n}\n\npublic Handler(Looper looper, Callback callback, boolean async) {\n    mLooper = looper;\n    mQueue = looper.mQueue;\n    ...\n}\n\n```\n呐，我们熟悉的异常：\n<br>*\"Can't create handler inside thread that has not called Looper.prepare()\"*</br>\nHandler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看\n上述的MQ就是Looper.mQueue\n并且Looper和MQ都是final的，构造完之后就不可改变\n到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑\n\n```java\n//MessageQueue.enqueueMessage\nboolean enqueueMessage(Message msg, long when) {\n\t\t//这个target就是handler引用\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n\t\t//消息不能重复使用，有需要记得clone一份\n    if (msg.isInUse()) {\n        throw new IllegalStateException(msg + \" This message is already in use.\");\n    }\n\n    synchronized (this) {\n\t\t//队列已经退出的逻辑处理\n\t\t//mQuitting状态标识是在MQ.quit()方法中被设为true的\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(TAG, e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\t\t//消息是在这里设置成已经消费了\n        msg.markInUse();\n\t\t//时间是在入队时候指定的，之前手动给消息赋时间没有意义\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n\t\t//空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头\n        if (p == null || when == 0 || when < p.when) {\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n\t\t\t//MQ中的消息是根据msg.when来排序的\n\t\t\t//根据msg.when给新来的Msg找个合适的位置插进去\n            for (;;) {\n                prev = p;\n                p = p.next;\n\t\t\t\t//1. p == null，说明找到队列尾部了还是没找到合适位置\n\t\t\t\t//2. when < p.when 说明找到一个比自己还要晚展示的消息\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n\t\t\t//插入msg\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n\n```\n啥也不说了，都在酒里了，哦不，在注释里\n上述也只是说了具体的Message入队的细节，还是没有将入队之后的事情\n那接下来就要去MQ对应的Looper里面看了\n\n```java\n//Lopper.loop()\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    // Make sure the identity of this thread is that of the local process,\n    // and keep track of what that identity token actually is.\n    Binder.clearCallingIdentity();\n    final long ident = Binder.clearCallingIdentity();\n\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n\t\t\t\t...\n        msg.target.dispatchMessage(msg);\n\t\t\t\t...\n        msg.recycleUnchecked();\n    }\n}\n\n\n```\n可以看到loop做的就是不停的取消息，然后调用msg.target.dispatchMessage(msg);\n\nloop这里有几点需要注意：\n\t1. loop方法是个死循环：for (;;) {}\n\t2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（懒得说了，你自行看下就明白）\n\n\n\n## Part3 扩展\n####  Handler的消息发到哪里了\nhandler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是一个消息，如果你愿意，完全可以Message.obtain(handler,runable)，再通过handler.sendMessage来发送runnable\n\n那么handler.sendMessageAt(msg,time) 的逻辑做的事情就是将msg入到消息队列里面去\nqueue.enqueueMessage(msg,time)\n\n####  ThreadLoacal是什么鬼\n每个讲Handler都要提到theadLocal,这个与主题没有一毛钱关系，将其理解成Thread一个Map就好，想详细了解的自行Google,个人觉得这东西与Handler原理扯不上关系\n\n####  MessageQueue是怎么组织的？BlockQueue?\n具体的实现都在native中 ？暂且当做BlockQueue来理解//todo\nenqueueMessage\n异常情况(msg.target == null  || msg.isInUse() )\nsendMessage会自动设置target,//什么场景下修改会为空？？\nmsg.isInUse会在入队列时候修改，所以在重复使用时候可以通过Message.obtain(msg)来客隆一份数据一样但是没有使用过的Message来使用\nsendMessageAtFrontOfQueue\n\n此队列并非先进先出队列，而是一个LinkedQueue,在enqueueMessage,会根据Message.when，将其插入到合适的位置，队列中的消息是按照when排序的\n\n\n####  Message.when\n在发消息时候发送一个when 比 当期MessageQueue时间还小的when即可插队到对头，你也许会说，我哪里知道当前对头的消息when是多少，所以直接设置when为0即可插队到对头，这可以应用在优先级高的处理\n\n但是when可以修改么？\nwhen是package访问权限(还好不是final)，是否可以通过新建一个与其包名相同的类来修改？\nwhen值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，不要煞费苦心修改了，平时直接发送的sendMessage的when就是0\n如果同时发送的消息如果都是0，还在排队处理的话，后来的消息会插在队列的前面，都是立即处理的话，处理谁都一样\n\n\n####  Message.target\nHandler.obtain系列会将Message.target赋值为this\n而Handler.postRunnable 获取的Message没有赋值target\n但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this\n也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper\n\n但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中\n\n\n####  sendMessage与postRunable有什么区别\n最终都是调用setMessageAt(msg,time),不同的是获取Message方式不同，postRunable是将unable赋值给message.callback\n\n\n\n\n## Part4 思考\n####  如何停止Looper\nLooper在loop的时候，如果取到一个Message为null，就会自行跳出，但是MessageQueue只有在队列为空和已经退出时候才会给Looper返回null. 不能通过发送null消息来停止，\n同时Looper本身也提供了quite api来退出循环，原理是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束\n\n在Looper中会调用msg.target.dispatchMessage(msg),这样又将消息返回给handler来执行了，而此时消息执行是looper中调用的，也就是消息执行是在looper所在的线程调用的，这样此消息也就在此线程被消费\n同时会调用msg.resycleUnchecked()回收此对象\n\n####  消息执行的优先级\n- 会先处理msg.callback也（post进来的runnable就是设置到callback中）\n- 如果handler有设置callback，消息会发送到callback的handlermessge()中消费\n- 如果没设置就在本handler.handlerMessage()中消费\n- 而一般情况下我的处理逻辑都在handlerMessage中，这样消息就又回来了\n####  聊一聊HandlerThread\n- http://blog.csdn.net/qq_23547831/article/details/50936584\n\n####  MainLooper ActivityThread.man() 如何做到一直待机\n\n\n####  为什么框架层要提示防止内存泄露？因为Looper会一直循环\n\n####  MessageQueue 的Barrier是什么鬼\n\n####  ActivityThread是个好东西\nActivityThread不是Thread\n","slug":"说一下Handler的原理","published":1,"updated":"2016-07-26T00:24:58.000Z","_id":"cir1fa41o000q2k222apwlhkc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Part1-Handler原理概述\"><a href=\"#Part1-Handler原理概述\" class=\"headerlink\" title=\"Part1 : Handler原理概述\"></a>Part1 : Handler原理概述</h2><h4 id=\"Handler在解决什么问题\"><a href=\"#Handler在解决什么问题\" class=\"headerlink\" title=\"Handler在解决什么问题?\"></a>Handler在解决什么问题?</h4><p>handler 是为了解决线程间通讯的问题而设计的</p>\n<pre><code>- 解决线程通讯一个通用的回调就可以，何必整真么多事出来\n- handler给我们的印象是更新UI用的，如何与线程通讯联系起来\n- 仅仅是线程通讯么？如果要通知的线程已经执行完任务销毁了呢？又如果，他自己在处理其他事情，没空理你呢？\n</code></pre><p>线程通讯回调:handler.sendMessageAt()<br>为什么用来更新UI，大多数情况我们是用来是子线程来通知主线程来操作的，所以造成了这么个印象<br>为了避免多个子线程与主线程通讯，造成的混乱，设计成队列处理，一个个排队来，处理完一个再有请下一位</p>\n<h4 id=\"Handler提供了哪些API功能\"><a href=\"#Handler提供了哪些API功能\" class=\"headerlink\" title=\"Handler提供了哪些API功能\"></a>Handler提供了哪些API功能</h4><p>对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了）</p>\n<pre><code>1. 发消息        sendMessageAt()\n2. 处理消息      handleMessage()\n</code></pre><p>这里对应就有两个疑问了:</p>\n<pre><code>1. 他的消息发给谁？\n2. 消息又是由谁来消费的?\n</code></pre><p>看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler<br>了解他们是如何协同工作的才能回答上述两个疑问</p>\n<p><img src=\"http://oaumghlfk.bkt.clouddn.com/handler.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10\" alt=\"Handler-flow\"></p>\n<ol>\n<li>整体上ThreadA持有handler，发送的消息，只是将消息塞到ThreadB的Looper的MessageQueue中</li>\n<li>MessageQueue中的消息会被与之对应的Looper逐个取出来</li>\n<li>执行Looper中的消息的主体是与Looper对应的ThreadB</li>\n<li>ThreadB只是调用message.target.dispatchMessage</li>\n<li>这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.handlerMessage</li>\n<li>但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑是在ThreadB上执行的</li>\n</ol>\n<p>他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,一个线程最多只有一个Looper</p>\n<p>再来回答那两个问题：<br>    Handler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中，而这个Looper对应的线程是哪一个，消息就会被那个线程消费</p>\n<h2 id=\"Part2-源码分析\"><a href=\"#Part2-源码分析\" class=\"headerlink\" title=\"Part2 : 源码分析\"></a>Part2 : 源码分析</h2><p>以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Handler.sendMessageAtTime 最终将消息入队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    MessageQueue queue = mQueue;</div><div class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//继续看Handler.enqueueMessage</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>OK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)</p>\n<p>那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Handler</span></div><div class=\"line\"><span class=\"keyword\">final</span> MessageQueue mQueue;</div><div class=\"line\"><span class=\"keyword\">final</span> Looper mLooper;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">    mLooper = Looper.myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mQueue = mLooper.mQueue;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    mLooper = looper;</div><div class=\"line\">    mQueue = looper.mQueue;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>呐，我们熟悉的异常：<br><br><em>“Can’t create handler inside thread that has not called Looper.prepare()”</em><br><br>Handler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看<br>上述的MQ就是Looper.mQueue<br>并且Looper和MQ都是final的，构造完之后就不可改变<br>到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MessageQueue.enqueueMessage</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//这个target就是handler引用</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t\t<span class=\"comment\">//消息不能重复使用，有需要记得clone一份</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//队列已经退出的逻辑处理</span></div><div class=\"line\">\t\t<span class=\"comment\">//mQuitting状态标识是在MQ.quit()方法中被设为true的</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">//消息是在这里设置成已经消费了</span></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">\t\t<span class=\"comment\">//时间是在入队时候指定的，之前手动给消息赋时间没有意义</span></div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</div><div class=\"line\">\t\t<span class=\"comment\">//空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">\t\t\t<span class=\"comment\">//MQ中的消息是根据msg.when来排序的</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//根据msg.when给新来的Msg找个合适的位置插进去</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//1. p == null，说明找到队列尾部了还是没找到合适位置</span></div><div class=\"line\">\t\t\t\t<span class=\"comment\">//2. when &lt; p.when 说明找到一个比自己还要晚展示的消息</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//插入msg</span></div><div class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>啥也不说了，都在酒里了，哦不，在注释里<br>上述也只是说了具体的Message入队的细节，还是没有将入队之后的事情<br>那接下来就要去MQ对应的Looper里面看了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Lopper.loop()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></div><div class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t\t\t...</div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\">\t\t\t\t...</div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到loop做的就是不停的取消息，然后调用msg.target.dispatchMessage(msg);</p>\n<p>loop这里有几点需要注意：</p>\n<pre><code>1. loop方法是个死循环：for (;;) {}\n2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（懒得说了，你自行看下就明白）\n</code></pre><h2 id=\"Part3-扩展\"><a href=\"#Part3-扩展\" class=\"headerlink\" title=\"Part3 扩展\"></a>Part3 扩展</h2><h4 id=\"Handler的消息发到哪里了\"><a href=\"#Handler的消息发到哪里了\" class=\"headerlink\" title=\"Handler的消息发到哪里了\"></a>Handler的消息发到哪里了</h4><p>handler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是一个消息，如果你愿意，完全可以Message.obtain(handler,runable)，再通过handler.sendMessage来发送runnable</p>\n<p>那么handler.sendMessageAt(msg,time) 的逻辑做的事情就是将msg入到消息队列里面去<br>queue.enqueueMessage(msg,time)</p>\n<h4 id=\"ThreadLoacal是什么鬼\"><a href=\"#ThreadLoacal是什么鬼\" class=\"headerlink\" title=\"ThreadLoacal是什么鬼\"></a>ThreadLoacal是什么鬼</h4><p>每个讲Handler都要提到theadLocal,这个与主题没有一毛钱关系，将其理解成Thread一个Map就好，想详细了解的自行Google,个人觉得这东西与Handler原理扯不上关系</p>\n<h4 id=\"MessageQueue是怎么组织的？BlockQueue\"><a href=\"#MessageQueue是怎么组织的？BlockQueue\" class=\"headerlink\" title=\"MessageQueue是怎么组织的？BlockQueue?\"></a>MessageQueue是怎么组织的？BlockQueue?</h4><p>具体的实现都在native中 ？暂且当做BlockQueue来理解//todo<br>enqueueMessage<br>异常情况(msg.target == null  || msg.isInUse() )<br>sendMessage会自动设置target,//什么场景下修改会为空？？<br>msg.isInUse会在入队列时候修改，所以在重复使用时候可以通过Message.obtain(msg)来客隆一份数据一样但是没有使用过的Message来使用<br>sendMessageAtFrontOfQueue</p>\n<p>此队列并非先进先出队列，而是一个LinkedQueue,在enqueueMessage,会根据Message.when，将其插入到合适的位置，队列中的消息是按照when排序的</p>\n<h4 id=\"Message-when\"><a href=\"#Message-when\" class=\"headerlink\" title=\"Message.when\"></a>Message.when</h4><p>在发消息时候发送一个when 比 当期MessageQueue时间还小的when即可插队到对头，你也许会说，我哪里知道当前对头的消息when是多少，所以直接设置when为0即可插队到对头，这可以应用在优先级高的处理</p>\n<p>但是when可以修改么？<br>when是package访问权限(还好不是final)，是否可以通过新建一个与其包名相同的类来修改？<br>when值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，不要煞费苦心修改了，平时直接发送的sendMessage的when就是0<br>如果同时发送的消息如果都是0，还在排队处理的话，后来的消息会插在队列的前面，都是立即处理的话，处理谁都一样</p>\n<h4 id=\"Message-target\"><a href=\"#Message-target\" class=\"headerlink\" title=\"Message.target\"></a>Message.target</h4><p>Handler.obtain系列会将Message.target赋值为this<br>而Handler.postRunnable 获取的Message没有赋值target<br>但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this<br>也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper</p>\n<p>但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中</p>\n<h4 id=\"sendMessage与postRunable有什么区别\"><a href=\"#sendMessage与postRunable有什么区别\" class=\"headerlink\" title=\"sendMessage与postRunable有什么区别\"></a>sendMessage与postRunable有什么区别</h4><p>最终都是调用setMessageAt(msg,time),不同的是获取Message方式不同，postRunable是将unable赋值给message.callback</p>\n<h2 id=\"Part4-思考\"><a href=\"#Part4-思考\" class=\"headerlink\" title=\"Part4 思考\"></a>Part4 思考</h2><h4 id=\"如何停止Looper\"><a href=\"#如何停止Looper\" class=\"headerlink\" title=\"如何停止Looper\"></a>如何停止Looper</h4><p>Looper在loop的时候，如果取到一个Message为null，就会自行跳出，但是MessageQueue只有在队列为空和已经退出时候才会给Looper返回null. 不能通过发送null消息来停止，<br>同时Looper本身也提供了quite api来退出循环，原理是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束</p>\n<p>在Looper中会调用msg.target.dispatchMessage(msg),这样又将消息返回给handler来执行了，而此时消息执行是looper中调用的，也就是消息执行是在looper所在的线程调用的，这样此消息也就在此线程被消费<br>同时会调用msg.resycleUnchecked()回收此对象</p>\n<h4 id=\"消息执行的优先级\"><a href=\"#消息执行的优先级\" class=\"headerlink\" title=\"消息执行的优先级\"></a>消息执行的优先级</h4><ul>\n<li>会先处理msg.callback也（post进来的runnable就是设置到callback中）</li>\n<li>如果handler有设置callback，消息会发送到callback的handlermessge()中消费</li>\n<li>如果没设置就在本handler.handlerMessage()中消费</li>\n<li>而一般情况下我的处理逻辑都在handlerMessage中，这样消息就又回来了<h4 id=\"聊一聊HandlerThread\"><a href=\"#聊一聊HandlerThread\" class=\"headerlink\" title=\"聊一聊HandlerThread\"></a>聊一聊HandlerThread</h4></li>\n<li><a href=\"http://blog.csdn.net/qq_23547831/article/details/50936584\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/qq_23547831/article/details/50936584</a></li>\n</ul>\n<h4 id=\"MainLooper-ActivityThread-man-如何做到一直待机\"><a href=\"#MainLooper-ActivityThread-man-如何做到一直待机\" class=\"headerlink\" title=\"MainLooper ActivityThread.man() 如何做到一直待机\"></a>MainLooper ActivityThread.man() 如何做到一直待机</h4><h4 id=\"为什么框架层要提示防止内存泄露？因为Looper会一直循环\"><a href=\"#为什么框架层要提示防止内存泄露？因为Looper会一直循环\" class=\"headerlink\" title=\"为什么框架层要提示防止内存泄露？因为Looper会一直循环\"></a>为什么框架层要提示防止内存泄露？因为Looper会一直循环</h4><h4 id=\"MessageQueue-的Barrier是什么鬼\"><a href=\"#MessageQueue-的Barrier是什么鬼\" class=\"headerlink\" title=\"MessageQueue 的Barrier是什么鬼\"></a>MessageQueue 的Barrier是什么鬼</h4><h4 id=\"ActivityThread是个好东西\"><a href=\"#ActivityThread是个好东西\" class=\"headerlink\" title=\"ActivityThread是个好东西\"></a>ActivityThread是个好东西</h4><p>ActivityThread不是Thread</p>\n","excerpt":"","more":"<h2 id=\"Part1-Handler原理概述\"><a href=\"#Part1-Handler原理概述\" class=\"headerlink\" title=\"Part1 : Handler原理概述\"></a>Part1 : Handler原理概述</h2><h4 id=\"Handler在解决什么问题\"><a href=\"#Handler在解决什么问题\" class=\"headerlink\" title=\"Handler在解决什么问题?\"></a>Handler在解决什么问题?</h4><p>handler 是为了解决线程间通讯的问题而设计的</p>\n<pre><code>- 解决线程通讯一个通用的回调就可以，何必整真么多事出来\n- handler给我们的印象是更新UI用的，如何与线程通讯联系起来\n- 仅仅是线程通讯么？如果要通知的线程已经执行完任务销毁了呢？又如果，他自己在处理其他事情，没空理你呢？\n</code></pre><p>线程通讯回调:handler.sendMessageAt()<br>为什么用来更新UI，大多数情况我们是用来是子线程来通知主线程来操作的，所以造成了这么个印象<br>为了避免多个子线程与主线程通讯，造成的混乱，设计成队列处理，一个个排队来，处理完一个再有请下一位</p>\n<h4 id=\"Handler提供了哪些API功能\"><a href=\"#Handler提供了哪些API功能\" class=\"headerlink\" title=\"Handler提供了哪些API功能\"></a>Handler提供了哪些API功能</h4><p>对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了）</p>\n<pre><code>1. 发消息        sendMessageAt()\n2. 处理消息      handleMessage()\n</code></pre><p>这里对应就有两个疑问了:</p>\n<pre><code>1. 他的消息发给谁？\n2. 消息又是由谁来消费的?\n</code></pre><p>看看我们熟悉的四基友：Thread - Looper - MessageQueue - Handler<br>了解他们是如何协同工作的才能回答上述两个疑问</p>\n<p><img src=\"http://oaumghlfk.bkt.clouddn.com/handler.png?watermark/2/text/dGVyZ2UubWU=/font/5a6L5L2T/fontsize/500/fill/I0E3MDYwNg==/dissolve/54/gravity/SouthEast/dx/10/dy/10\" alt=\"Handler-flow\"></p>\n<ol>\n<li>整体上ThreadA持有handler，发送的消息，只是将消息塞到ThreadB的Looper的MessageQueue中</li>\n<li>MessageQueue中的消息会被与之对应的Looper逐个取出来</li>\n<li>执行Looper中的消息的主体是与Looper对应的ThreadB</li>\n<li>ThreadB只是调用message.target.dispatchMessage</li>\n<li>这个target兄便是ThreadA的handler,这样消息在人间这么走一遭，逻辑上又会执行到Handler.handlerMessage</li>\n<li>但是这个dispatchMessage是ThreadB来调用的，也就是此msg的逻辑是在ThreadB上执行的</li>\n</ol>\n<p>他们的关系，Handler实例化需要一个Looper,Looper内部维护一个MQ,一个线程最多只有一个Looper</p>\n<p>再来回答那两个问题：<br>    Handler实例化时候用了哪个Lopper,消息就会发送到那个looper对应的MessageQueue中，而这个Looper对应的线程是哪一个，消息就会被那个线程消费</p>\n<h2 id=\"Part2-源码分析\"><a href=\"#Part2-源码分析\" class=\"headerlink\" title=\"Part2 : 源码分析\"></a>Part2 : 源码分析</h2><p>以上是结论，那么我们现在从源码角度来跟着Message，去人世间走一遭</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Handler.sendMessageAtTime 最终将消息入队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    MessageQueue queue = mQueue;</div><div class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//继续看Handler.enqueueMessage</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>OK，Handler.sendMessage 执行的逻辑是MessageQueue.enqueueMessage(msg,time)</p>\n<p>那么这个MQ（以下都将MessageQueue简称为MQ）是哪里来的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Handler</span></div><div class=\"line\"><span class=\"keyword\">final</span> MessageQueue mQueue;</div><div class=\"line\"><span class=\"keyword\">final</span> Looper mLooper;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">    mLooper = Looper.myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">            <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mQueue = mLooper.mQueue;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Looper looper, Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    mLooper = looper;</div><div class=\"line\">    mQueue = looper.mQueue;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>呐，我们熟悉的异常：<br><br><em>“Can’t create handler inside thread that has not called Looper.prepare()”</em></br><br>Handler 实例化时候是需要一个Looper的，如果没传递进来，就会直接获取当前线程的Looper,如果当前线程未开启Looper,就死给你看<br>上述的MQ就是Looper.mQueue<br>并且Looper和MQ都是final的，构造完之后就不可改变<br>到此Handler这一边的逻辑就告一段落，我们继续梳理MQ.equeue之后的逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//MessageQueue.enqueueMessage</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//这个target就是handler引用</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Message must have a target.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t\t<span class=\"comment\">//消息不能重复使用，有需要记得clone一份</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">\" This message is already in use.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">\t\t<span class=\"comment\">//队列已经退出的逻辑处理</span></div><div class=\"line\">\t\t<span class=\"comment\">//mQuitting状态标识是在MQ.quit()方法中被设为true的</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</div><div class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</div><div class=\"line\">                    msg.target + <span class=\"string\">\" sending message to a Handler on a dead thread\"</span>);</div><div class=\"line\">            Log.w(TAG, e.getMessage(), e);</div><div class=\"line\">            msg.recycle();</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">//消息是在这里设置成已经消费了</span></div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">\t\t<span class=\"comment\">//时间是在入队时候指定的，之前手动给消息赋时间没有意义</span></div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</div><div class=\"line\">\t\t<span class=\"comment\">//空队列 ，或者非延时消息，或者消息比对头消息还早，直接插队在队头</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">            needWake = mBlocked;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">            Message prev;</div><div class=\"line\">\t\t\t<span class=\"comment\">//MQ中的消息是根据msg.when来排序的</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//根据msg.when给新来的Msg找个合适的位置插进去</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//1. p == null，说明找到队列尾部了还是没找到合适位置</span></div><div class=\"line\">\t\t\t\t<span class=\"comment\">//2. when &lt; p.when 说明找到一个比自己还要晚展示的消息</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">//插入msg</span></div><div class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>啥也不说了，都在酒里了，哦不，在注释里<br>上述也只是说了具体的Message入队的细节，还是没有将入队之后的事情<br>那接下来就要去MQ对应的Looper里面看了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Lopper.loop()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</div><div class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></div><div class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></div><div class=\"line\">    Binder.clearCallingIdentity();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t\t\t...</div><div class=\"line\">        msg.target.dispatchMessage(msg);</div><div class=\"line\">\t\t\t\t...</div><div class=\"line\">        msg.recycleUnchecked();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到loop做的就是不停的取消息，然后调用msg.target.dispatchMessage(msg);</p>\n<p>loop这里有几点需要注意：</p>\n<pre><code>1. loop方法是个死循环：for (;;) {}\n2. 只有取得的msg为空时候才会退出死循环，那这个消息什么时候为空？（懒得说了，你自行看下就明白）\n</code></pre><h2 id=\"Part3-扩展\"><a href=\"#Part3-扩展\" class=\"headerlink\" title=\"Part3 扩展\"></a>Part3 扩展</h2><h4 id=\"Handler的消息发到哪里了\"><a href=\"#Handler的消息发到哪里了\" class=\"headerlink\" title=\"Handler的消息发到哪里了\"></a>Handler的消息发到哪里了</h4><p>handler.sendMessage 和handler.postRunanable其实质上最后都是调用到handler.sendMessageAt(msg,time)，runnable只是赋值给了msg.callback,也是一个消息，如果你愿意，完全可以Message.obtain(handler,runable)，再通过handler.sendMessage来发送runnable</p>\n<p>那么handler.sendMessageAt(msg,time) 的逻辑做的事情就是将msg入到消息队列里面去<br>queue.enqueueMessage(msg,time)</p>\n<h4 id=\"ThreadLoacal是什么鬼\"><a href=\"#ThreadLoacal是什么鬼\" class=\"headerlink\" title=\"ThreadLoacal是什么鬼\"></a>ThreadLoacal是什么鬼</h4><p>每个讲Handler都要提到theadLocal,这个与主题没有一毛钱关系，将其理解成Thread一个Map就好，想详细了解的自行Google,个人觉得这东西与Handler原理扯不上关系</p>\n<h4 id=\"MessageQueue是怎么组织的？BlockQueue\"><a href=\"#MessageQueue是怎么组织的？BlockQueue\" class=\"headerlink\" title=\"MessageQueue是怎么组织的？BlockQueue?\"></a>MessageQueue是怎么组织的？BlockQueue?</h4><p>具体的实现都在native中 ？暂且当做BlockQueue来理解//todo<br>enqueueMessage<br>异常情况(msg.target == null  || msg.isInUse() )<br>sendMessage会自动设置target,//什么场景下修改会为空？？<br>msg.isInUse会在入队列时候修改，所以在重复使用时候可以通过Message.obtain(msg)来客隆一份数据一样但是没有使用过的Message来使用<br>sendMessageAtFrontOfQueue</p>\n<p>此队列并非先进先出队列，而是一个LinkedQueue,在enqueueMessage,会根据Message.when，将其插入到合适的位置，队列中的消息是按照when排序的</p>\n<h4 id=\"Message-when\"><a href=\"#Message-when\" class=\"headerlink\" title=\"Message.when\"></a>Message.when</h4><p>在发消息时候发送一个when 比 当期MessageQueue时间还小的when即可插队到对头，你也许会说，我哪里知道当前对头的消息when是多少，所以直接设置when为0即可插队到对头，这可以应用在优先级高的处理</p>\n<p>但是when可以修改么？<br>when是package访问权限(还好不是final)，是否可以通过新建一个与其包名相同的类来修改？<br>when值来自 sendMessageAt的那个时间，在enqueue时候在MessageQueue里面被赋值，不要煞费苦心修改了，平时直接发送的sendMessage的when就是0<br>如果同时发送的消息如果都是0，还在排队处理的话，后来的消息会插在队列的前面，都是立即处理的话，处理谁都一样</p>\n<h4 id=\"Message-target\"><a href=\"#Message-target\" class=\"headerlink\" title=\"Message.target\"></a>Message.target</h4><p>Handler.obtain系列会将Message.target赋值为this<br>而Handler.postRunnable 获取的Message没有赋值target<br>但是无论哪种方式，最终会在enqueueMessage中将target赋值为Handler.this<br>也就是是说在使用哪个Handler发送消息，最终一定是进了他的Looper</p>\n<p>但是一旦enqueueMessage后，处理逻辑就以及脱离了Handler的控制了，执行的结果都只会发送到Message.target中</p>\n<h4 id=\"sendMessage与postRunable有什么区别\"><a href=\"#sendMessage与postRunable有什么区别\" class=\"headerlink\" title=\"sendMessage与postRunable有什么区别\"></a>sendMessage与postRunable有什么区别</h4><p>最终都是调用setMessageAt(msg,time),不同的是获取Message方式不同，postRunable是将unable赋值给message.callback</p>\n<h2 id=\"Part4-思考\"><a href=\"#Part4-思考\" class=\"headerlink\" title=\"Part4 思考\"></a>Part4 思考</h2><h4 id=\"如何停止Looper\"><a href=\"#如何停止Looper\" class=\"headerlink\" title=\"如何停止Looper\"></a>如何停止Looper</h4><p>Looper在loop的时候，如果取到一个Message为null，就会自行跳出，但是MessageQueue只有在队列为空和已经退出时候才会给Looper返回null. 不能通过发送null消息来停止，<br>同时Looper本身也提供了quite api来退出循环，原理是调用MQ.quite，在下一个next时候MQ返回给Looper一个null,这样Looper就自行结束</p>\n<p>在Looper中会调用msg.target.dispatchMessage(msg),这样又将消息返回给handler来执行了，而此时消息执行是looper中调用的，也就是消息执行是在looper所在的线程调用的，这样此消息也就在此线程被消费<br>同时会调用msg.resycleUnchecked()回收此对象</p>\n<h4 id=\"消息执行的优先级\"><a href=\"#消息执行的优先级\" class=\"headerlink\" title=\"消息执行的优先级\"></a>消息执行的优先级</h4><ul>\n<li>会先处理msg.callback也（post进来的runnable就是设置到callback中）</li>\n<li>如果handler有设置callback，消息会发送到callback的handlermessge()中消费</li>\n<li>如果没设置就在本handler.handlerMessage()中消费</li>\n<li>而一般情况下我的处理逻辑都在handlerMessage中，这样消息就又回来了<h4 id=\"聊一聊HandlerThread\"><a href=\"#聊一聊HandlerThread\" class=\"headerlink\" title=\"聊一聊HandlerThread\"></a>聊一聊HandlerThread</h4></li>\n<li><a href=\"http://blog.csdn.net/qq_23547831/article/details/50936584\">http://blog.csdn.net/qq_23547831/article/details/50936584</a></li>\n</ul>\n<h4 id=\"MainLooper-ActivityThread-man-如何做到一直待机\"><a href=\"#MainLooper-ActivityThread-man-如何做到一直待机\" class=\"headerlink\" title=\"MainLooper ActivityThread.man() 如何做到一直待机\"></a>MainLooper ActivityThread.man() 如何做到一直待机</h4><h4 id=\"为什么框架层要提示防止内存泄露？因为Looper会一直循环\"><a href=\"#为什么框架层要提示防止内存泄露？因为Looper会一直循环\" class=\"headerlink\" title=\"为什么框架层要提示防止内存泄露？因为Looper会一直循环\"></a>为什么框架层要提示防止内存泄露？因为Looper会一直循环</h4><h4 id=\"MessageQueue-的Barrier是什么鬼\"><a href=\"#MessageQueue-的Barrier是什么鬼\" class=\"headerlink\" title=\"MessageQueue 的Barrier是什么鬼\"></a>MessageQueue 的Barrier是什么鬼</h4><h4 id=\"ActivityThread是个好东西\"><a href=\"#ActivityThread是个好东西\" class=\"headerlink\" title=\"ActivityThread是个好东西\"></a>ActivityThread是个好东西</h4><p>ActivityThread不是Thread</p>\n"},{"title":"说下现在做的SDK的整体架构","_content":"","source":"_drafts/说下现在做的SDK的整体架构.md","raw":"---\ntitle: 说下现在做的SDK的整体架构\ntags:\n---\n","slug":"说下现在做的SDK的整体架构","published":0,"date":"2016-07-24T08:06:58.986Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41p000r2k22q8kbsx04","content":"","excerpt":"","more":""},{"title":"说说你的ClassLoader的理解","_content":"","source":"_drafts/说说你的ClassLoader的理解.md","raw":"---\ntitle: 说说你的ClassLoader的理解\ntags:\n---\n","slug":"说说你的ClassLoader的理解","published":0,"date":"2016-07-24T08:06:58.986Z","updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41r000s2k22kvu3kvg0","content":"","excerpt":"","more":""},{"title":"WHY？HOW? WHEN?","date":"2016-07-16T07:12:05.000Z","_content":"\nWHY ? 为什么要写\n\n    1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚\n    2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维\n    3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西\n\n\nHOW ? 怎样写\n\n    1. 为了解决什么问题\n    2. 具体是怎么去解决此问题的\n    3. 有哪些相似的方案，优劣如何\n    4. 具体的应用场景\n    5. 思考\n    6. 原创\n\n\n\nWHEN ? 什么时候写\n\n    目标可达，就要求有具体的时间，不然没法衡量\n    对于这里的技术文章，<font color=red>每周写一篇</font>\n","source":"_posts/WHY-HOW-WHEN.md","raw":"---\ntitle: WHY？HOW? WHEN?\ndate: 2016-07-16 15:12:05\ntags:\n---\n\nWHY ? 为什么要写\n\n    1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚\n    2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维\n    3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西\n\n\nHOW ? 怎样写\n\n    1. 为了解决什么问题\n    2. 具体是怎么去解决此问题的\n    3. 有哪些相似的方案，优劣如何\n    4. 具体的应用场景\n    5. 思考\n    6. 原创\n\n\n\nWHEN ? 什么时候写\n\n    目标可达，就要求有具体的时间，不然没法衡量\n    对于这里的技术文章，<font color=red>每周写一篇</font>\n","slug":"WHY-HOW-WHEN","published":1,"updated":"2016-07-24T07:32:41.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cir1fa41s000t2k220kvgenaw","content":"<p>WHY ? 为什么要写</p>\n<pre><code>1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚\n2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维\n3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西\n</code></pre><p>HOW ? 怎样写</p>\n<pre><code>1. 为了解决什么问题\n2. 具体是怎么去解决此问题的\n3. 有哪些相似的方案，优劣如何\n4. 具体的应用场景\n5. 思考\n6. 原创\n</code></pre><p>WHEN ? 什么时候写</p>\n<pre><code>目标可达，就要求有具体的时间，不然没法衡量\n对于这里的技术文章，&lt;font color=red&gt;每周写一篇&lt;/font&gt;\n</code></pre>","excerpt":"","more":"<p>WHY ? 为什么要写</p>\n<pre><code>1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚\n2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维\n3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西\n</code></pre><p>HOW ? 怎样写</p>\n<pre><code>1. 为了解决什么问题\n2. 具体是怎么去解决此问题的\n3. 有哪些相似的方案，优劣如何\n4. 具体的应用场景\n5. 思考\n6. 原创\n</code></pre><p>WHEN ? 什么时候写</p>\n<pre><code>目标可达，就要求有具体的时间，不然没法衡量\n对于这里的技术文章，&lt;font color=red&gt;每周写一篇&lt;/font&gt;\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}