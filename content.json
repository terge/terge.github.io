{"meta":{"title":"Terge's Android Life","subtitle":"主动、无畏、习惯、沉淀","description":"description","author":"唐自刚","url":"http://terge.me"},"pages":[{"title":"tags","date":"2016-07-19T12:21:22.000Z","updated":"2016-07-19T12:22:32.058Z","comments":false,"path":"tags/index.html","permalink":"http://terge.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"说一下Handler的原理","slug":"说一下Handler的原理","date":"2016-07-16T07:33:31.000Z","updated":"2016-07-18T03:22:09.887Z","comments":true,"path":"2016/07/16/说一下Handler的原理/","link":"","permalink":"http://terge.me/2016/07/16/说一下Handler的原理/","excerpt":"","text":"Handler在解决什么问题? handler 是为了解决线程间通讯的问题而设计的 那么，如果没有handler，如何做到线程A与线程B进行通讯？回调？监听？这样的话，要么每次都要定义自己所写回调接口，双方必须定义好回调参数格式，要么定义一个通用方法，而handler其实就相当于这个通用的方法egg:主线程 启动了子线程A去完成一项任务，并对A说”你拿着这个handler，等你做完了用它告诉我就可以”，等到A做完了，通过handler.sendMessage来发出暗号，这时候主线程收到这个消息，就知道A已经做完了，然后去处理对应的逻辑。 对于这个功能，handler要定义成通用逻辑，所以handler提供了如下功能来满足不同业务场景需要（同性质的功能就不一一列出了） 1. obtainMessage() //获取一个空消息 2. sendMessage(Message msg) //发送消息 3. handleMessage(Message msg) //收到消息 4. post(Runnable r) //抛出一个runnable 5. removeCallbacks(Runnable r) //移除runnable 以上就构成了一个通用的回调逻辑，实际上我的很多的回调接口都可以通过此方式进行，用好系统提供的现成功能，一般情况下都好过于自己单独开发，除非你很清楚它并不能满足自己的需求 好了，线程通讯的问题解决了，看起来并没有什么特殊的，就是定义了一个通用的回调方案，然而我们都知道那个Looper还没提到 loop (来自有道词典) 英 [luːp] 美 [lup] vi. 打环；翻筋斗 n. 环；圈；弯曲部分；翻筋斗 vt. 使成环；以环连结；使翻筋斗 Looper从字面理解就是，一直再循环的那个东西这里就要提到Android单线程的概念了","categories":[],"tags":[]},{"title":"WHY？HOW? WHEN?","slug":"WHY-HOW-WHEN","date":"2016-07-16T07:12:05.000Z","updated":"2016-07-16T07:35:21.000Z","comments":true,"path":"2016/07/16/WHY-HOW-WHEN/","link":"","permalink":"http://terge.me/2016/07/16/WHY-HOW-WHEN/","excerpt":"","text":"WHY ? 为什么要写 1. 教学相长：能说清楚才叫真的懂，为了真的懂，就得说清楚 2. 文案套路：写一个东西，要怎么讲，才能让人听起来自然，且能理解我我所表达的东西，这个很重要，在工作中，设计文档，以及邮件说明问题时候都需要这种思维 3. 知识沉淀：已经理解一个东西，些许日志不接触，就会生疏，又重头查一遍，得不偿失，得有一个地方去整理这些东西 HOW ? 怎样写 1. 为了解决什么问题 2. 具体是怎么去解决此问题的 3. 有哪些相似的方案，优劣如何 4. 具体的应用场景 5. 思考 6. 原创 WHEN ? 什么时候写 目标可达，就要求有具体的时间，不然没法衡量 对于这里的技术文章，&lt;font color=red&gt;每周写一篇&lt;/font&gt;","categories":[],"tags":[]}]}